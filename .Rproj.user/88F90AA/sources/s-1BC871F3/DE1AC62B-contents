splines <- "
	data{
int<lower=0> N; // Number of samples
int<lower=0> num_basis; // Dimension of basis matrix
int<lower=0> t; // number of time points
vector[t * N] Y;
matrix[N,2] X;
matrix[t, num_basis] B;
int<lower=0> K;
}
parameters{
matrix[num_basis,2] a;
real<lower=0> precision;
vector[N] Z[K];
matrix[num_basis, 2] Lam[K];
matrix<lower=0>[2, 2] smooth_inv;
}
transformed parameters{
vector[t * N] Y_hat;
real<lower=0> sigma;
matrix<lower=0>[2, 2] smooth;
Y_hat = to_vector(B*a*X');
for(k in 1:K){
Y_hat = Y_hat + to_vector(B*Lam[k]*X'*diag_matrix(Z[k]));
}
sigma = inv(sqrt(precision));
smooth = 1 ./ smooth_inv;
}
model{
precision ~ gamma(.0001, .0001);
for(k in 1:K){
Z[k] ~ normal(0,1);
}
to_vector(smooth_inv) ~ gamma(1, .00005);
for(k in 1:K){
for(i in 1:num_basis){
for(j in 1:2){
if(i == 1){
Lam[k, i, j] ~ normal(0, smooth[2,j]);
a[i, j] ~ normal(0, smooth[1,j]);
}
else if(i == 2){
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j], smooth[1,j]);
}
else {
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j] - Lam[k,i-2,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j] - a[i-2,j], smooth[1,j]);

}
}
}
}

Y ~ normal(Y_hat, sigma);

}
"
m <- stan_model(model_code = splines)

setwd("/Users/John/Documents/Johnstuff/BayesianConditionalFPCA/Rfuns")
{
  library(MASS)
  library(splines)
  library(mvtnorm)
  library(plot3D)
  library(splines)
  library(Rcpp)
  library(microbenchmark)
  library(dlnm)
  mu <- function(t, z){
    t + z*sin(t) + (1-z)*cos(t)
  }
  
  tmax <- 50
  zmax <- 30
  t <- seq(from = 0, to = 1, length.out = tmax)
  z <- seq(from = 0, to = 1, length.out = zmax)
  
  meanfunc <- numeric(0)
  for(i in 1:zmax){
    meanfunc <- c(meanfunc, mu(t, z[i]))
  }
  p <- 12
  B <- bs(t, df = p, intercept = TRUE)
  X <- numeric(0)
  X <- cbind(rep(1,zmax), z)
  X <- kronecker(X, B)
  reg1 <- lm(meanfunc ~ X - 1)
  num <- 29
  idx <- (1 + tmax*num):(tmax*(num+1))
  plot(meanfunc[idx],type="l")
  lines(X[idx,]%*%reg1$coefficients,col="blue")
  
  eig1 <- function(t,z){
    -cos(pi*(t+z/2))/sqrt(2) * sqrt(z/9)
  }
  eigfunc1 <- numeric(0)
  for(i in 1:zmax){
    eigfunc1 <- c(eigfunc1, eig1(t,z[i]))
  }
  reg2 <- lm(eigfunc1 ~ X - 1)
  
  eig2 <- function(t,z){
    sin(pi*(t+z/2))/sqrt(2) * sqrt(z/36)
  }
  eigfunc2 <- numeric(0)
  for(i in 1:zmax){
    eigfunc2 <- c(eigfunc2, eig2(t, z[i]))
  }
  reg3 <- lm(eigfunc2 ~ X - 1)
  plot(eigfunc1[idx], type="l")
  lines(X[idx,]%*%reg2$coefficients, col = "blue")
  
  Theta <- matrix(reg1$coefficients, nrow = p, ncol = 2)
  L1 <- matrix(reg2$coefficients, nrow = p, ncol = 2)
  L2 <- matrix(reg3$coefficients, nrow = p, ncol = 2)
}

{
  set.seed(2)
  N <- 200
  tmax <- 50
  p <- 12
  T <- seq(from = 0, to = 1, length.out = tmax)
  library(plot3D)
  library(splines)
  #Btru <- ps(T, df = p)
  Btru <- bs(T, df = p, intercept = TRUE)
  #X <- cbind(rep(1,n))
  #X <- cbind(rep(1,n),runif(n,min=-1,max=1))
  X <- cbind(rep(1,N), rnorm(N, sd = .1))
  d <- dim(X)[2]
  Eta1 <- rnorm(N)
  Eta2 <- rnorm(N)
  Y <- matrix(0, nrow = N, ncol = tmax)
  #Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
  #Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
  Lambda1 <- L1
  Lambda2 <- L2
  #Lambda%*%t(Lambda)
  #Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
  E <- matrix(rnorm(tmax * N,sd=.05), nrow = N, ncol = tmax)
  Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
  Y <- t(Y)
  Ycol <- c(Y)
}
plot(Y[,1],type="p")
num_basis_est <- 25
B_est <- ps(T, df = num_basis_est, diff = 1, intercept = TRUE)
reg <- lm(Ycol ~ kronecker(X, B_est)-1)
init <- list(list(a = matrix(reg$coefficients, ncol = 2)))
K <- 2
data1 = list(N = N, num_basis = num_basis_est, t = tmax, Y = Ycol, X = X, B = B_est, K = K)

fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv"))
posterior <- extract(fitvb)


plot(T,Ycol[101:150])
for(i in 1:1000){
  y_hat <- B_est%*%posterior$a[i,,]%*%X[3,]
  for(k in 1:K){
    y_hat <- y_hat + B_est%*%posterior$Lam[i,k,,]%*%X[3,]*posterior$Z[i,k,3]
  }
  lines(T, y_hat, col="gray")
}
#lines(tp,c(Y_true)[101:150], col = "red")


x <- c(1,1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
  for(k in 1:K){
    cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
  }
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))

plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
  lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
  
}
lines(B_true%*%alpha%*%x,type="l",col="red")

fit <- sampling(m, data = data1, chains=1, iter=5000, thin = 1, par = c("a", "Lam", "Z", "sigma"), init = init, warmup = 2500)

posterior <- extract(fit)