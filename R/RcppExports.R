# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

cppgetX <- function(EtaM, EtaV, X, newX, cores = 1L) {
    invisible(.Call(`_BayesianConditionalFPCA_cppgetX`, EtaM, EtaV, X, newX, cores))
}

cppupdateall <- function(Theta, Lambda, precision, newX, B, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall`, Theta, Lambda, precision, newX, B, newY, K))
}

cppupdateall_Proj <- function(Theta, Lambda, Phi, newX, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall_Proj`, Theta, Lambda, Phi, newX, newY, K))
}

cppupdateeta <- function(Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta`, Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K))
}

cppupdateeta_Proj <- function(Theta, Lambda, Phi, EtaM, EtaV, X, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta_Proj`, Theta, Lambda, Phi, EtaM, EtaV, X, Y, K))
}

cpploglik <- function(Theta, Lambda, precision, X, B, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik`, Theta, Lambda, precision, X, B, Y, K, cores)
}

cpploglik_Proj <- function(Theta, Lambda, Phi, X, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik_Proj`, Theta, Lambda, Phi, X, Y, K, cores)
}

completeY2Means <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY2Means`, Y, missing_sub, missing_time))
}

cpp_EM2 <- function(X, B, Y, K, tol, max_iter) {
    .Call(`_BayesianConditionalFPCA_cpp_EM2`, X, B, Y, K, tol, max_iter)
}

cpp_EM <- function(X, B, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM`, X, B, Y, K, Theta_init, cores)
}

cpp_EM_Proj <- function(X, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_Proj`, X, Y, K, Theta_init, cores)
}

cpp_EM_new <- function(X, B, Y, K, Theta_init, Lambda_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_new`, X, B, Y, K, Theta_init, Lambda_init, cores)
}

get_proposal <- function(old) {
    .Call(`_BayesianConditionalFPCA_get_proposal`, old)
}

armadillo_modulus2 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus2`, indicies, n)
}

armadillo_modulus3 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus3`, indicies, n)
}

get_omnibus_fit <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit`, mod)
}

get_omnibus_fit2 <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit2`, mod)
}

DiffOp <- function(n) {
    .Call(`_BayesianConditionalFPCA_DiffOp`, n)
}

getPenalty2 <- function(n, D) {
    .Call(`_BayesianConditionalFPCA_getPenalty2`, n, D)
}

getPenalty <- function(n) {
    .Call(`_BayesianConditionalFPCA_getPenalty`, n)
}

initializeY <- function(y, observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_initializeY`, y, observedTimes, fullTimes)
}

getObservedOrder <- function(observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_getObservedOrder`, observedTimes, fullTimes)
}

PredictY <- function(ImputedY, X, B, Theta, Eta, Lambda, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY`, ImputedY, X, B, Theta, Eta, Lambda, Prec))
}

PredictY2 <- function(ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY2`, ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec))
}

Proposal <- function(Theta, Lambda, noise, samples) {
    .Call(`_BayesianConditionalFPCA_Proposal`, Theta, Lambda, noise, samples)
}

cpploglik_bayes <- function(Theta, Lambda, precision, Phi, X, B, Y, cores) {
    .Call(`_BayesianConditionalFPCA_cpploglik_bayes`, Theta, Lambda, precision, Phi, X, B, Y, cores)
}

find_stepsize <- function(Y, Theta, Lambda, prec, X, B, noise) {
    invisible(.Call(`_BayesianConditionalFPCA_find_stepsize`, Y, Theta, Lambda, prec, X, B, noise))
}

get_posterior_predictive_bands <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands`, mod, quantiles)
}

get_posterior_predictive_bands2 <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands2`, mod, quantiles)
}

get_posterior_subject_bands_cpp <- function(mcmc_output, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_subject_bands_cpp`, mcmc_output, alpha)
}

get_posterior_means_cpp_correct <- function(mcmc_results, xi, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_means_cpp_correct`, mcmc_results, xi, alpha)
}

get_posterior_coefs <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_coefs`, mod, alpha)
}

arma_cov2cor <- function(V) {
    .Call(`_BayesianConditionalFPCA_arma_cov2cor`, V)
}

get_posterior_eigen_cpp_correct <- function(mcmc_results, eigenvals, zi, alpha = 0.05) {
    .Call(`_BayesianConditionalFPCA_get_posterior_eigen_cpp_correct`, mcmc_results, eigenvals, zi, alpha)
}

get_variance_effects <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_variance_effects`, mod, alpha)
}

#' Run Markov-Chain Monte-Carlo
#' 
#' Generate samples from the posterior distribution. This 
#' algorithm pre-dominantly uses Gibbs sampling
#' @param response N x T response matrix, where N is number of subjects and T is number
#' of time points. Values can be NA if there's missing data
#' @param design_mean N x d_{1} design matrix for mean structure
#' @param design_var N x d_{2} design matrix for the covariance structure
#' @param basis User generated basis matrix
#' @param time vector of time points
#' @param penalties_mean List of smoothing penalties for mean structure
#' @param penalties_var List of smoothin penalties for covariance structure
#' @param indices_mean Maps penalties in the mean structure to beta coefficients
#' @param indices_var Maps penalties in the covariance structure to lambda
#' coefficients
#' @param kdim Dimension of latent subspace
#' @param iter Number of iterations to run
#' @param burnin Number of iterations to use as burn-in. This is only relevant when
#' passing the returned object into post-processing functions
#' @param thin Thinning defaulting to 1
#' @param var Can be set to "unequal" to estimate subject-specific measurement
#' errors or "pooled" to estimate a pooled measurement error variance
#' @export run_mcmc
#' @return A List containing 3 lists including data, control, and samples.
run_mcmc <- function(response, design_mean, design_var, basis, time, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin = 1L, var = "unequal") {
    .Call(`_BayesianConditionalFPCA_run_mcmc`, response, design_mean, design_var, basis, time, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin, var)
}

