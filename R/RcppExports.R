# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

cppgetX <- function(EtaM, EtaV, X, newX, cores = 1L) {
    invisible(.Call(`_BayesianConditionalFPCA_cppgetX`, EtaM, EtaV, X, newX, cores))
}

cppupdateall <- function(Theta, Lambda, precision, newX, B, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall`, Theta, Lambda, precision, newX, B, newY, K))
}

cppupdateall_Proj <- function(Theta, Lambda, Phi, newX, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall_Proj`, Theta, Lambda, Phi, newX, newY, K))
}

cppupdateeta <- function(Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta`, Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K))
}

cppupdateeta_Proj <- function(Theta, Lambda, Phi, EtaM, EtaV, X, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta_Proj`, Theta, Lambda, Phi, EtaM, EtaV, X, Y, K))
}

cpploglik <- function(Theta, Lambda, precision, X, B, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik`, Theta, Lambda, precision, X, B, Y, K, cores)
}

cpploglik_Proj <- function(Theta, Lambda, Phi, X, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik_Proj`, Theta, Lambda, Phi, X, Y, K, cores)
}

completeY2Means <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY2Means`, Y, missing_sub, missing_time))
}

cpp_EM2 <- function(X, B, Y, K, tol, max_iter) {
    .Call(`_BayesianConditionalFPCA_cpp_EM2`, X, B, Y, K, tol, max_iter)
}

cpp_EM <- function(X, B, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM`, X, B, Y, K, Theta_init, cores)
}

cpp_EM_Proj <- function(X, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_Proj`, X, Y, K, Theta_init, cores)
}

cpp_EM_new <- function(X, B, Y, K, Theta_init, Lambda_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_new`, X, B, Y, K, Theta_init, Lambda_init, cores)
}

armadillo_modulus <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus`, indicies, n)
}

completeY <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY`, Y, missing_sub, missing_time))
}

MCMC_Impute <- function(y, observedTimes, fullTimes, X, B, K, iter, nchains, thin) {
    .Call(`_BayesianConditionalFPCA_MCMC_Impute`, y, observedTimes, fullTimes, X, B, K, iter, nchains, thin)
}

completeY2 <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY2`, Y, missing_sub, missing_time))
}

run_mcmc_Morris <- function(Y, Time, X, Z, B, K, iter, burnin, nchains, thin, loglik) {
    .Call(`_BayesianConditionalFPCA_run_mcmc_Morris`, Y, Time, X, Z, B, K, iter, burnin, nchains, thin, loglik)
}

run_mcmc_Morris_Tensor <- function(Y, Time, X, Z, B, MeanPenalties, VarPenalties, Meanindices, Varindices, K, iter, burnin, nchains, thin, loglik) {
    .Call(`_BayesianConditionalFPCA_run_mcmc_Morris_Tensor`, Y, Time, X, Z, B, MeanPenalties, VarPenalties, Meanindices, Varindices, K, iter, burnin, nchains, thin, loglik)
}

BuildBlkDiag <- function(Penalties, indices, Tau, BlkDiag) {
    invisible(.Call(`_BayesianConditionalFPCA_BuildBlkDiag`, Penalties, indices, Tau, BlkDiag))
}

testfunc <- function() {
    invisible(.Call(`_BayesianConditionalFPCA_testfunc`))
}

MCMC_Sparse <- function(Y, X, B, K, iter, nchains, thin) {
    .Call(`_BayesianConditionalFPCA_MCMC_Sparse`, Y, X, B, K, iter, nchains, thin)
}

MCMC_Tempered <- function(Y, X, B, K, iter, nchains, thin, beta, Theta_init, Lambda_init, Eta_init, Prec_init) {
    .Call(`_BayesianConditionalFPCA_MCMC_Tempered`, Y, X, B, K, iter, nchains, thin, beta, Theta_init, Lambda_init, Eta_init, Prec_init)
}

MCMC_Wrapper <- function(Y, X, B, K, iter, nchains, thin, Theta_init, Lambda_init, Eta_init) {
    .Call(`_BayesianConditionalFPCA_MCMC_Wrapper`, Y, X, B, K, iter, nchains, thin, Theta_init, Lambda_init, Eta_init)
}

TemperedMCMC <- function(Y, X, B, K, iter, thin, Theta_init, Lambda_init, Eta_init, Prec_init, beta) {
    .Call(`_BayesianConditionalFPCA_TemperedMCMC`, Y, X, B, K, iter, thin, Theta_init, Lambda_init, Eta_init, Prec_init, beta)
}

get_proposal <- function(old) {
    .Call(`_BayesianConditionalFPCA_get_proposal`, old)
}

armadillo_modulus2 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus2`, indicies, n)
}

armadillo_modulus3 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus3`, indicies, n)
}

get_omnibus_fit <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit`, mod)
}

get_omnibus_fit2 <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit2`, mod)
}

DiffOp <- function(n) {
    .Call(`_BayesianConditionalFPCA_DiffOp`, n)
}

getPenalty2 <- function(n, D) {
    .Call(`_BayesianConditionalFPCA_getPenalty2`, n, D)
}

getPenalty <- function(n) {
    .Call(`_BayesianConditionalFPCA_getPenalty`, n)
}

initializeY <- function(y, observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_initializeY`, y, observedTimes, fullTimes)
}

getObservedOrder <- function(observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_getObservedOrder`, observedTimes, fullTimes)
}

PredictY <- function(ImputedY, X, B, Theta, Eta, Lambda, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY`, ImputedY, X, B, Theta, Eta, Lambda, Prec))
}

PredictY2 <- function(ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY2`, ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec))
}

Proposal <- function(Theta, Lambda, noise, samples) {
    .Call(`_BayesianConditionalFPCA_Proposal`, Theta, Lambda, noise, samples)
}

cpploglik_bayes <- function(Theta, Lambda, precision, Phi, X, B, Y, cores) {
    .Call(`_BayesianConditionalFPCA_cpploglik_bayes`, Theta, Lambda, precision, Phi, X, B, Y, cores)
}

find_stepsize <- function(Y, Theta, Lambda, prec, X, B, noise) {
    invisible(.Call(`_BayesianConditionalFPCA_find_stepsize`, Y, Theta, Lambda, prec, X, B, noise))
}

get_posterior_predictive_bands <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands`, mod, quantiles)
}

get_posterior_predictive_bands2 <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands2`, mod, quantiles)
}

get_posterior_subject_bands_cpp <- function(mcmc_output, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_subject_bands_cpp`, mcmc_output, alpha)
}

get_posterior_means_cpp <- function(mcmc_results, xi, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_means_cpp`, mcmc_results, xi, alpha)
}

get_posterior_coefs <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_coefs`, mod, alpha)
}

arma_cov2cor <- function(V) {
    .Call(`_BayesianConditionalFPCA_arma_cov2cor`, V)
}

get_posterior_eigen_cpp <- function(mcmc_results, eigenvals, zi, alpha = 0.05) {
    .Call(`_BayesianConditionalFPCA_get_posterior_eigen_cpp`, mcmc_results, eigenvals, zi, alpha)
}

get_variance_effects <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_variance_effects`, mod, alpha)
}

rcpparma_hello_world <- function() {
    .Call(`_BayesianConditionalFPCA_rcpparma_hello_world`)
}

rcpparma_outerproduct <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_outerproduct`, x)
}

rcpparma_innerproduct <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_innerproduct`, x)
}

rcpparma_bothproducts <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_bothproducts`, x)
}

#' Run Markov-Chain Monte-Carlo
#' 
#' Generate samples from the posterior distribution. This 
#' algorithm pre-dominantly uses Gibbs sampling
#' @param response N x T response matrix, where N is number of subjects and T is number
#' of time points. Values can be NA if there's missing data
#' @param design_mean N x d_{1} design matrix for mean structure
#' @param design_var N x d_{2} design matrix for the covariance structure
#' @param basis User generated basis matrix
#' @param time vector of time points
#' @param penalties_mean List of smoothing penalties for mean structure
#' @param penalties_var List of smoothin penalties for covariance structure
#' @param indices_mean Maps penalties in the mean structure to beta coefficients
#' @param indices_var Maps penalties in the covariance structure to lambda
#' coefficients
#' @param kdim Dimension of latent subspace
#' @param iter Number of iterations to run
#' @param burnin Number of iterations to use as burn-in. This is only relevant when
#' passing the returned object into post-processing functions
#' @param thin Thinning defaulting to 1
#' @param var Can be set to "unequal" to estimate subject-specific measurement
#' errors or "pooled" to estimate a pooled measurement error variance
#' @export run_mcmc
#' @return A List containing 3 lists including data, control, and samples.
run_mcmc <- function(response, design_mean, design_var, basis, time, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin = 1L, var = "unequal") {
    .Call(`_BayesianConditionalFPCA_run_mcmc`, response, design_mean, design_var, basis, time, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin, var)
}

timesTwo <- function(x) {
    .Call(`_BayesianConditionalFPCA_timesTwo`, x)
}

updateProjBeta <- function(Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj, beta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateProjBeta`, Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj, beta))
}

updatePrecPBeta <- function(Proj, Y, B, beta) {
    .Call(`_BayesianConditionalFPCA_updatePrecPBeta`, Proj, Y, B, beta)
}

updateTauBeta <- function(Theta, Lambda, Tau, beta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTauBeta`, Theta, Lambda, Tau, beta))
}

choose_coordinate <- function(log_weights) {
    .Call(`_BayesianConditionalFPCA_choose_coordinate`, log_weights)
}

updateThetaLambdaPT <- function(Lambda, Theta, Eta, Delta, Proj, Tau, X, beta) {
    .Call(`_BayesianConditionalFPCA_updateThetaLambdaPT`, Lambda, Theta, Eta, Delta, Proj, Tau, X, beta)
}

updateEtaPT <- function(Lambda, Theta, Eta, Delta, Proj, X, beta) {
    .Call(`_BayesianConditionalFPCA_updateEtaPT`, Lambda, Theta, Eta, Delta, Proj, X, beta)
}

updateProj <- function(Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj) {
    invisible(.Call(`_BayesianConditionalFPCA_updateProj`, Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj))
}

updateThetaLambdaP <- function(Lambda, Theta, Eta, Delta, Proj, Tau, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambdaP`, Lambda, Theta, Eta, Delta, Proj, Tau, X))
}

updateEtaP <- function(Lambda, Theta, Eta, Delta, Proj, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEtaP`, Lambda, Theta, Eta, Delta, Proj, X))
}

updateDelta <- function(Proj, Theta, Lambda, Eta, Delta, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateDelta`, Proj, Theta, Lambda, Eta, Delta, X))
}

updatePrecP <- function(Proj, Y, B) {
    .Call(`_BayesianConditionalFPCA_updatePrecP`, Proj, Y, B)
}

updateLambda <- function(Y, Lambda, r, Gamma, X, B, prec) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambda`, Y, Lambda, r, Gamma, X, B, prec))
}

updateLambda2 <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambda2`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateTheta <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTheta`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateTheta2 <- function(Y, Lambda, Tau, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTheta2`, Y, Lambda, Tau, X, B, prec, Theta))
}

updateThetaLambda <- function(Y, Lambda, Eta, Tau, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambda`, Y, Lambda, Eta, Tau, X, B, prec, Theta))
}

updateThetaLambdaMH <- function(Y, Theta, Lambda, Tau, prec, X, B, noise, n) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambdaMH`, Y, Theta, Lambda, Tau, prec, X, B, noise, n))
}

updateEta <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updateEta2 <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta2`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updateEta3 <- function(Y, Lambda, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta3`, Y, Lambda, Eta, X, B, prec, Theta))
}

updatePrec <- function(Y, Lambda, Gamma, X, B, Theta) {
    .Call(`_BayesianConditionalFPCA_updatePrec`, Y, Lambda, Gamma, X, B, Theta)
}

updateTau <- function(Theta, Lambda, Tau) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTau`, Theta, Lambda, Tau))
}

updateSigma <- function(Eta, Sigma) {
    invisible(.Call(`_BayesianConditionalFPCA_updateSigma`, Eta, Sigma))
}

updateSigBeta <- function(sigma, SigBeta, Phi, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateSigBeta`, sigma, SigBeta, Phi, X))
}

updateLambdaS <- function(Y, Lambda, Tau, c, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambdaS`, Y, Lambda, Tau, c, Gamma, X, B, prec, Theta))
}

updateThetaS <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaS`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateEtaS <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEtaS`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updatePrecS <- function(Y, Lambda, Gamma, X, B, Theta) {
    .Call(`_BayesianConditionalFPCA_updatePrecS`, Y, Lambda, Gamma, X, B, Theta)
}

