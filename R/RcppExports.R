# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

cppgetX <- function(EtaM, EtaV, X, newX, cores = 1L) {
    invisible(.Call(`_BayesianConditionalFPCA_cppgetX`, EtaM, EtaV, X, newX, cores))
}

cppupdateall <- function(Theta, Lambda, precision, newX, B, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall`, Theta, Lambda, precision, newX, B, newY, K))
}

cppupdateall_Proj <- function(Theta, Lambda, Phi, newX, newY, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateall_Proj`, Theta, Lambda, Phi, newX, newY, K))
}

cppupdateeta <- function(Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta`, Theta, Lambda, precision, EtaM, EtaV, X, B, Y, K))
}

cppupdateeta_Proj <- function(Theta, Lambda, Phi, EtaM, EtaV, X, Y, K) {
    invisible(.Call(`_BayesianConditionalFPCA_cppupdateeta_Proj`, Theta, Lambda, Phi, EtaM, EtaV, X, Y, K))
}

cpploglik <- function(Theta, Lambda, precision, X, B, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik`, Theta, Lambda, precision, X, B, Y, K, cores)
}

cpploglik_Proj <- function(Theta, Lambda, Phi, X, Y, K, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik_Proj`, Theta, Lambda, Phi, X, Y, K, cores)
}

completeY2Means <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY2Means`, Y, missing_sub, missing_time))
}

cpp_EM2 <- function(X, B, Y, K, tol, max_iter) {
    .Call(`_BayesianConditionalFPCA_cpp_EM2`, X, B, Y, K, tol, max_iter)
}

cpp_EM <- function(X, B, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM`, X, B, Y, K, Theta_init, cores)
}

cpp_EM_Proj <- function(X, Y, K, Theta_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_Proj`, X, Y, K, Theta_init, cores)
}

cpp_EM_new <- function(X, B, Y, K, Theta_init, Lambda_init, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpp_EM_new`, X, B, Y, K, Theta_init, Lambda_init, cores)
}

armadillo_modulus <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus`, indicies, n)
}

completeY <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY`, Y, missing_sub, missing_time))
}

MCMC_Impute <- function(y, observedTimes, fullTimes, X, B, K, iter, nchains, thin) {
    .Call(`_BayesianConditionalFPCA_MCMC_Impute`, y, observedTimes, fullTimes, X, B, K, iter, nchains, thin)
}

completeY2 <- function(Y, missing_sub, missing_time) {
    invisible(.Call(`_BayesianConditionalFPCA_completeY2`, Y, missing_sub, missing_time))
}

run_mcmc_Morris <- function(Y, Time, X, Z, B, K, iter, burnin, nchains, thin, loglik) {
    .Call(`_BayesianConditionalFPCA_run_mcmc_Morris`, Y, Time, X, Z, B, K, iter, burnin, nchains, thin, loglik)
}

run_mcmc_Morris_Tensor <- function(Y, Time, X, Z, B, MeanPenalties, VarPenalties, Meanindices, Varindices, K, iter, burnin, nchains, thin, loglik) {
    .Call(`_BayesianConditionalFPCA_run_mcmc_Morris_Tensor`, Y, Time, X, Z, B, MeanPenalties, VarPenalties, Meanindices, Varindices, K, iter, burnin, nchains, thin, loglik)
}

BuildBlkDiag <- function(Penalties, indices, Tau, BlkDiag) {
    invisible(.Call(`_BayesianConditionalFPCA_BuildBlkDiag`, Penalties, indices, Tau, BlkDiag))
}

testfunc <- function() {
    invisible(.Call(`_BayesianConditionalFPCA_testfunc`))
}

MCMC_Sparse <- function(Y, X, B, K, iter, nchains, thin) {
    .Call(`_BayesianConditionalFPCA_MCMC_Sparse`, Y, X, B, K, iter, nchains, thin)
}

MCMC_Tempered <- function(Y, X, B, K, iter, nchains, thin, beta, Theta_init, Lambda_init, Eta_init, Prec_init) {
    .Call(`_BayesianConditionalFPCA_MCMC_Tempered`, Y, X, B, K, iter, nchains, thin, beta, Theta_init, Lambda_init, Eta_init, Prec_init)
}

MCMC_Wrapper <- function(Y, X, B, K, iter, nchains, thin, Theta_init, Lambda_init, Eta_init) {
    .Call(`_BayesianConditionalFPCA_MCMC_Wrapper`, Y, X, B, K, iter, nchains, thin, Theta_init, Lambda_init, Eta_init)
}

TemperedMCMC <- function(Y, X, B, K, iter, thin, Theta_init, Lambda_init, Eta_init, Prec_init, beta) {
    .Call(`_BayesianConditionalFPCA_TemperedMCMC`, Y, X, B, K, iter, thin, Theta_init, Lambda_init, Eta_init, Prec_init, beta)
}

armadillo_modulus2 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus2`, indicies, n)
}

armadillo_modulus3 <- function(indicies, n) {
    .Call(`_BayesianConditionalFPCA_armadillo_modulus3`, indicies, n)
}

get_omnibus_fit <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit`, mod)
}

get_omnibus_fit2 <- function(mod) {
    .Call(`_BayesianConditionalFPCA_get_omnibus_fit2`, mod)
}

DiffOp <- function(n) {
    .Call(`_BayesianConditionalFPCA_DiffOp`, n)
}

getPenalty2 <- function(n, D) {
    .Call(`_BayesianConditionalFPCA_getPenalty2`, n, D)
}

getPenalty <- function(n) {
    .Call(`_BayesianConditionalFPCA_getPenalty`, n)
}

initializeY <- function(y, observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_initializeY`, y, observedTimes, fullTimes)
}

getObservedOrder <- function(observedTimes, fullTimes) {
    .Call(`_BayesianConditionalFPCA_getObservedOrder`, observedTimes, fullTimes)
}

PredictY <- function(ImputedY, X, B, Theta, Eta, Lambda, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY`, ImputedY, X, B, Theta, Eta, Lambda, Prec))
}

PredictY2 <- function(ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec) {
    invisible(.Call(`_BayesianConditionalFPCA_PredictY2`, ImputedY, observedOrder, X, B, Theta, Lambda, Eta, Prec))
}

Proposal <- function(Theta, Lambda, noise = .1, samples = 200L) {
    .Call(`_BayesianConditionalFPCA_Proposal`, Theta, Lambda, noise, samples)
}

cpploglik_bayes <- function(Theta, Lambda, precision, Phi, X, B, Y, cores = 1L) {
    .Call(`_BayesianConditionalFPCA_cpploglik_bayes`, Theta, Lambda, precision, Phi, X, B, Y, cores)
}

find_stepsize <- function(Y, Theta, Lambda, prec, X, B, noise) {
    invisible(.Call(`_BayesianConditionalFPCA_find_stepsize`, Y, Theta, Lambda, prec, X, B, noise))
}

get_posterior_predictive_bands <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands`, mod, quantiles)
}

get_posterior_predictive_bands2 <- function(mod, quantiles) {
    .Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands2`, mod, quantiles)
}

get_posterior_predictive_bands69 <- function(mcmc_output, quantiles) {
    invisible(.Call(`_BayesianConditionalFPCA_get_posterior_predictive_bands69`, mcmc_output, quantiles))
}

get_posterior_means <- function(mod, xi, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_means`, mod, xi, alpha)
}

get_posterior_coefs <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_coefs`, mod, alpha)
}

extract_eigenfn <- function(Lambda, Delta, Psi, Psi_sqrt, Psi_sqrt_inv, B, eigenvals, z) {
    .Call(`_BayesianConditionalFPCA_extract_eigenfn`, Lambda, Delta, Psi, Psi_sqrt, Psi_sqrt_inv, B, eigenvals, z)
}

get_posterior_eigen <- function(mod, eigenvals, zi, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_eigen`, mod, eigenvals, zi, alpha)
}

extract_eigenfn2 <- function(Lambda, Psi, Psi_sqrt, Psi_sqrt_inv, B, eigenvals, z) {
    .Call(`_BayesianConditionalFPCA_extract_eigenfn2`, Lambda, Psi, Psi_sqrt, Psi_sqrt_inv, B, eigenvals, z)
}

arma_cov2cor <- function(V) {
    .Call(`_BayesianConditionalFPCA_arma_cov2cor`, V)
}

#' Posterior inference for covariate-adjusted covariance function
#' 
#' @param mod mcmc object
#' @param eigenvals Number of eigenvalues to keep
#' @param zi Covariate vector of interest
#' @param alpha Type I error rate
#' @details Generates posterior inference for covariate adjusted
#'  eigenfunctions, surfaces, and magnitudes
#' @return
#' An R list containing the following elements 
#' 
#' \code{lower} A matrix containing the lower bound of the simultaneous 
#' credible band of eigenfunctions  
#' 
#' \code{mean} A matrix containing the posterior mean of eigenfunctions  
#' 
#' \code{upper} A matrix containing the upper bound of the simultaneous 
#' credible band of eigenfunctions  
#' 
#' \code{eigenval_intervals} A matrix containing a 1-alpha credible interval
#' for eigenvalues  
#' 
#' \code{eigenval_pve_intervals} A matrix containing a 1-alpha credible 
#' interval for relative eigenvalues  
#' 
#' \code{surface} Posterior covariance surface  
#' 
#' \code{magnitude} Total variance of the fitted covariance surface across, one
#' for each sample
#' 
#' \code{raw_magnitude} 1-alpha credible interval for total variance
#' @export
get_posterior_eigen2 <- function(mod, eigenvals, zi, alpha) {
    .Call(`_BayesianConditionalFPCA_get_posterior_eigen2`, mod, eigenvals, zi, alpha)
}

get_variance_effects <- function(mod, alpha) {
    .Call(`_BayesianConditionalFPCA_get_variance_effects`, mod, alpha)
}

rcpparma_hello_world <- function() {
    .Call(`_BayesianConditionalFPCA_rcpparma_hello_world`)
}

rcpparma_outerproduct <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_outerproduct`, x)
}

rcpparma_innerproduct <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_innerproduct`, x)
}

rcpparma_bothproducts <- function(x) {
    .Call(`_BayesianConditionalFPCA_rcpparma_bothproducts`, x)
}

run_mcmc <- function(response, design_mean, design_var, basis, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin = 1L, var = "unequal") {
    .Call(`_BayesianConditionalFPCA_run_mcmc`, response, design_mean, design_var, basis, penalties_mean, penalties_var, indices_mean, indices_var, kdim, iter, burnin, thin, var)
}

timesTwo <- function(x) {
    .Call(`_BayesianConditionalFPCA_timesTwo`, x)
}

updateProjBeta <- function(Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj, beta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateProjBeta`, Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj, beta))
}

updatePrecPBeta <- function(Proj, Y, B, beta) {
    .Call(`_BayesianConditionalFPCA_updatePrecPBeta`, Proj, Y, B, beta)
}

updateTauBeta <- function(Theta, Lambda, Tau, beta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTauBeta`, Theta, Lambda, Tau, beta))
}

choose_coordinate <- function(log_weights) {
    .Call(`_BayesianConditionalFPCA_choose_coordinate`, log_weights)
}

updateThetaLambdaPT <- function(Lambda, Theta, Eta, Delta, Proj, Tau, X, beta) {
    .Call(`_BayesianConditionalFPCA_updateThetaLambdaPT`, Lambda, Theta, Eta, Delta, Proj, Tau, X, beta)
}

updateEtaPT <- function(Lambda, Theta, Eta, Delta, Proj, X, beta) {
    .Call(`_BayesianConditionalFPCA_updateEtaPT`, Lambda, Theta, Eta, Delta, Proj, X, beta)
}

updateProj <- function(Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj) {
    invisible(.Call(`_BayesianConditionalFPCA_updateProj`, Lambda, Theta, Eta, Delta, Prec, X, Y, B, Proj))
}

updateThetaLambdaP <- function(Lambda, Theta, Eta, Delta, Proj, Tau, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambdaP`, Lambda, Theta, Eta, Delta, Proj, Tau, X))
}

updateEtaP <- function(Lambda, Theta, Eta, Delta, Proj, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEtaP`, Lambda, Theta, Eta, Delta, Proj, X))
}

updateDelta <- function(Proj, Theta, Lambda, Eta, Delta, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateDelta`, Proj, Theta, Lambda, Eta, Delta, X))
}

updatePrecP <- function(Proj, Y, B) {
    .Call(`_BayesianConditionalFPCA_updatePrecP`, Proj, Y, B)
}

updateLambda <- function(Y, Lambda, r, Gamma, X, B, prec) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambda`, Y, Lambda, r, Gamma, X, B, prec))
}

updateLambda2 <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambda2`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateTheta <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTheta`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateTheta2 <- function(Y, Lambda, Tau, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTheta2`, Y, Lambda, Tau, X, B, prec, Theta))
}

updateThetaLambda <- function(Y, Lambda, Eta, Tau, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambda`, Y, Lambda, Eta, Tau, X, B, prec, Theta))
}

updateThetaLambdaMH <- function(Y, Theta, Lambda, Tau, prec, X, B, noise, n) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaLambdaMH`, Y, Theta, Lambda, Tau, prec, X, B, noise, n))
}

updateEta <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updateEta2 <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta2`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updateEta3 <- function(Y, Lambda, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEta3`, Y, Lambda, Eta, X, B, prec, Theta))
}

updatePrec <- function(Y, Lambda, Gamma, X, B, Theta) {
    .Call(`_BayesianConditionalFPCA_updatePrec`, Y, Lambda, Gamma, X, B, Theta)
}

updateTau <- function(Theta, Lambda, Tau) {
    invisible(.Call(`_BayesianConditionalFPCA_updateTau`, Theta, Lambda, Tau))
}

updateSigma <- function(Eta, Sigma) {
    invisible(.Call(`_BayesianConditionalFPCA_updateSigma`, Eta, Sigma))
}

updateSigBeta <- function(sigma, SigBeta, Phi, X) {
    invisible(.Call(`_BayesianConditionalFPCA_updateSigBeta`, sigma, SigBeta, Phi, X))
}

updateLambdaS <- function(Y, Lambda, Tau, c, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateLambdaS`, Y, Lambda, Tau, c, Gamma, X, B, prec, Theta))
}

updateThetaS <- function(Y, Lambda, Tau, Gamma, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateThetaS`, Y, Lambda, Tau, Gamma, X, B, prec, Theta))
}

updateEtaS <- function(Y, Lambda, Sigma, Eta, X, B, prec, Theta) {
    invisible(.Call(`_BayesianConditionalFPCA_updateEtaS`, Y, Lambda, Sigma, Eta, X, B, prec, Theta))
}

updatePrecS <- function(Y, Lambda, Gamma, X, B, Theta) {
    .Call(`_BayesianConditionalFPCA_updatePrecS`, Y, Lambda, Gamma, X, B, Theta)
}

