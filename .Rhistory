T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,N), rnorm(N, sd = .1))
d <- dim(X)[2]
Eta1 <- rnorm(N)
Eta2 <- rnorm(N)
Y <- matrix(0, nrow = N, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * N,sd=.05), nrow = N, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
Y <- t(Y)
Ycol <- c(Y)
plot(Y[,1],type="p")
plot(Y[,2],type="p")
plot(Y[,4],type="p")
plot(Y[,10],type="p")
plot(Y[,15],type="p")
x <- c(1,1)
plot(B%*%Theta%*%x,type="l",col="red")
x <- c(1,-1)
plot(B%*%Theta%*%x,type="l",col="red")
X
{
set.seed(2)
N <- 200
tmax <- 50
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,N), rnorm(N, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(N)
Eta2 <- rnorm(N)
Y <- matrix(0, nrow = N, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * N,sd=.05), nrow = N, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
Y <- t(Y)
Ycol <- c(Y)
}
plot(Y[,15],type="p")
{
set.seed(2)
N <- 200
tmax <- 50
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,N), rnorm(N, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(N)
Eta2 <- rnorm(N)
Y <- matrix(0, nrow = N, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * N,sd=.1), nrow = N, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
Y <- t(Y)
Ycol <- c(Y)
}
plot(Y[,15],type="p")
plot(Y[,1],type="p")
plot(Y[,2],type="p")
plot(Y[,3],type="p")
plot(Y[,4],type="p")
plot(Y[,5],type="p")
plot(Y[,6],type="p")
dim(dim())
dim(Y)
num_basis_est <- 25
B_est <- ps(T, df = num_basis_est, diff = 1, intercept = TRUE)
reg <- lm(Ycol ~ kronecker(X, B_est)-1)
init <- list(list(a = matrix(reg$coefficients, ncol = 2)))
K <- 2
data1 = list(N = N, num_basis = num_basis_est, t = tmax, Y = Ycol, X = X, B = B_est, K = K)
fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv"))
posterior <- extract(fitvb)
plot(T,Ycol[101:150])
for(i in 1:1000){
y_hat <- B_est%*%posterior$a[i,,]%*%X[3,]
for(k in 1:K){
y_hat <- y_hat + B_est%*%posterior$Lam[i,k,,]%*%X[3,]*posterior$Z[i,k,3]
}
lines(T, y_hat, col="gray")
}
x <- c(1,-1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
x <- c(1,1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
lines(B_true%*%alpha%*%x,type="l",col="red")
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
x <- c(1,-1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
x <- c(1,-2)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
lines(B%*%alpha%*%x,type="l",col="red")
lines(B%*%Theta%*%x,type="l",col="red")
num_basis_est <- 12
B_est <- ps(T, df = num_basis_est, diff = 1, intercept = TRUE)
reg <- lm(Ycol ~ kronecker(X, B_est)-1)
init <- list(list(a = matrix(reg$coefficients, ncol = 2)))
K <- 2
data1 = list(N = N, num_basis = num_basis_est, t = tmax, Y = Ycol, X = X, B = B_est, K = K)
fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv"))
posterior <- extract(fitvb)
plot(T,Ycol[101:150])
for(i in 1:1000){
y_hat <- B_est%*%posterior$a[i,,]%*%X[3,]
for(k in 1:K){
y_hat <- y_hat + B_est%*%posterior$Lam[i,k,,]%*%X[3,]*posterior$Z[i,k,3]
}
lines(T, y_hat, col="gray")
}
x <- c(1,-2)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
lines(B%*%Theta%*%x,type="l",col="red")
x <- c(1,-1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
x <- c(1,0)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
x <- c(1,1)
cov_true <- B%*%L1%*%outer(x,x)%*%t(L1)%*%t(B) + B%*%L2%*%outer(x,x)%*%t(L2)%*%t(B)
cov_est <- matrix(0,nrow = length(T), ncol = length(T))
for(i in 1:1000){
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
library(plot3D)
par(mfrow = c(1,2))
persp3D(T,T, cov_est, phi = 10, zlim = c(min(cov_true), max(cov_true)))
persp3D(T,T, cov_true, phi = 10, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B%*%Theta%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
lines(B%*%Theta%*%x,type="l",col="red")
sum((cov_est-c_true))
sum((cov_est-cov_true))
sum((cov_est-cov_true)^2)/sum((cov_true)^2)
sum((cov_est-cov_true)^2)/sum((cov_true)^2)*100
N
library(BayesianConditionalFPCA)
B
getwd()
setwd("/Users/John/Documents/Johnstuff/BayesianConditionalFPCA/Rfuns")
setwd("E:\\Rcpp stuff\\BayesianConditionalFPCA")
{
library(MASS)
library(splines)
library(mvtnorm)
library(plot3D)
library(splines)
library(Rcpp)
library(microbenchmark)
library(dlnm)
library(BayesianConditionalFPCA)
mu <- function(t, z){
t + z*sin(t) + (1-z)*cos(t)
}
tmax <- 50
zmax <- 30
t <- seq(from = 0, to = 1, length.out = tmax)
z <- seq(from = 0, to = 1, length.out = zmax)
meanfunc <- numeric(0)
for(i in 1:zmax){
meanfunc <- c(meanfunc, mu(t, z[i]))
}
p <- 12
B <- bs(t, df = p, intercept = TRUE)
X <- numeric(0)
X <- cbind(rep(1,zmax), z)
X <- kronecker(X, B)
reg1 <- lm(meanfunc ~ X - 1)
num <- 29
idx <- (1 + tmax*num):(tmax*(num+1))
plot(meanfunc[idx],type="l")
lines(X[idx,]%*%reg1$coefficients,col="blue")
eig1 <- function(t,z){
-cos(pi*(t+z/2))/sqrt(2) * sqrt(z/9)
}
eigfunc1 <- numeric(0)
for(i in 1:zmax){
eigfunc1 <- c(eigfunc1, eig1(t,z[i]))
}
reg2 <- lm(eigfunc1 ~ X - 1)
eig2 <- function(t,z){
sin(pi*(t+z/2))/sqrt(2) * sqrt(z/36)
}
eigfunc2 <- numeric(0)
for(i in 1:zmax){
eigfunc2 <- c(eigfunc2, eig2(t, z[i]))
}
reg3 <- lm(eigfunc2 ~ X - 1)
plot(eigfunc1[idx], type="l")
lines(X[idx,]%*%reg2$coefficients, col = "blue")
Theta <- matrix(reg1$coefficients, nrow = p, ncol = 2)
L1 <- matrix(reg2$coefficients, nrow = p, ncol = 2)
L2 <- matrix(reg3$coefficients, nrow = p, ncol = 2)
}
{
set.seed(2)
n <- 200
tmax <- 50
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,n), rnorm(n, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.001), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
plot(Y[1,],type="p")
{
set.seed(2)
n <- 200
tmax <- 50
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,n), rnorm(n, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.05), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
plot(Y[1,],type="p")
set.seed(3)
p <- 25
#B <- bs(T, df = p, intercept = TRUE)
B <- ps(T, df = p, diff = 1, intercept = TRUE)
K <- 2
Xmat <- kronecker(B, X)
reg <- lm(c(Y) ~ Xmat - 1)
Theta_init <- t(matrix(reg$coefficients, nrow = 2))
param <- cpp_EM(X, B, Y, K,Theta_init, 12)
cpploglik(Theta, cbind(L1,L2), 1/.001^2, X, Btru, Y, 2, 6)
cpploglik(param$Theta, param$Lambda, param$Precision, X, B, Y, K,1)
max_iter <- 15000
burnin <- 5000
thin <- 1
nchain <- 6
Lambda_init <- array(param$Lambda, dim = c(p, 2, 2))
Eta_init <- t(param$EtaM)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, param$Theta, Lambda_init, Eta_init)
x <- c(1,-1)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
lines(B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 10)){
lines(B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(Btru%*%Theta%*%x, type = "l",col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
library(BayesianConditionalFPCA)
setwd("E:\\Rcpp stuff\\BayesianConditionalFPCA")
{
library(MASS)
library(splines)
library(mvtnorm)
library(plot3D)
library(splines)
library(Rcpp)
library(microbenchmark)
library(dlnm)
library(BayesianConditionalFPCA)
mu <- function(t, z){
t + z*sin(t) + (1-z)*cos(t)
}
tmax <- 50
zmax <- 30
t <- seq(from = 0, to = 1, length.out = tmax)
z <- seq(from = 0, to = 1, length.out = zmax)
meanfunc <- numeric(0)
for(i in 1:zmax){
meanfunc <- c(meanfunc, mu(t, z[i]))
}
p <- 12
B <- bs(t, df = p, intercept = TRUE)
X <- numeric(0)
X <- cbind(rep(1,zmax), z)
X <- kronecker(X, B)
reg1 <- lm(meanfunc ~ X - 1)
num <- 29
idx <- (1 + tmax*num):(tmax*(num+1))
plot(meanfunc[idx],type="l")
lines(X[idx,]%*%reg1$coefficients,col="blue")
eig1 <- function(t,z){
-cos(pi*(t+z/2))/sqrt(2) * sqrt(z/9)
}
eigfunc1 <- numeric(0)
for(i in 1:zmax){
eigfunc1 <- c(eigfunc1, eig1(t,z[i]))
}
reg2 <- lm(eigfunc1 ~ X - 1)
eig2 <- function(t,z){
sin(pi*(t+z/2))/sqrt(2) * sqrt(z/36)
}
eigfunc2 <- numeric(0)
for(i in 1:zmax){
eigfunc2 <- c(eigfunc2, eig2(t, z[i]))
}
reg3 <- lm(eigfunc2 ~ X - 1)
plot(eigfunc1[idx], type="l")
lines(X[idx,]%*%reg2$coefficients, col = "blue")
Theta <- matrix(reg1$coefficients, nrow = p, ncol = 2)
L1 <- matrix(reg2$coefficients, nrow = p, ncol = 2)
L2 <- matrix(reg3$coefficients, nrow = p, ncol = 2)
}
