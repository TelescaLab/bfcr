T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
#X <- cbind(rep(1,n), c(rep(0, n/2), rep(1,n/2)))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
X <- cbind(rep(1,n), rnorm(n, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda1 <- L1[,1]
#Lambda2 <- L2[,1]
Lambda1 <-  10*L1
Lambda2 <-  10*L2
#Theta1 <- Theta[,1]
Theta1 <- 1*Theta
#X <- as.matrix(X[,1])
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
noise_sd <- .1
E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
Y <- X%*%t(Theta1)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
set.seed(2)
p <- 12
#B <- bs(T, df = p, intercept = TRUE)
B <- ps(T, df = p, diff = 1, intercept = TRUE)
K <- 2
Xmat <- kronecker(B, X)
reg <- lm(c(Y) ~ Xmat - 1)
Theta_init <- t(matrix(reg$coefficients, nrow = 2))
param <- cpp_EM(X, B, Y, K, Theta_init, p)
print(c("log likelihood to beat is", cpploglik(Theta1, cbind(Lambda1,Lambda2), 1/noise_sd^2, X, Btru, Y, 2, 6)))
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
# EM initialization
{
Theta_init <- param$Theta
Lambda_init <- array(param$Lambda, dim = c(p, 2, K))
Eta_init <- t(param$EtaM)
Prec_init <- param$Precision
}
max_iter <- 1000
burnin <- 100
thin <- 1
nchain <- 1
set.seed(2)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,-.5)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1.35, 1.65))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 10)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
cov1 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1
for(a in 1:K){
cov1 <- cov1 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov2 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1000
for(a in 1:K){
cov2 <- cov2 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov3 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 500
for(a in 1:K){
cov3 <- cov3 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
persp3D(1:tmax,1:tmax, cov1, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov2, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov3, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
dev.off()
persp3D(1:tmax,1:tmax, cov1, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov2, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov3, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
{
set.seed(1)
n <- 400
tmax <- 50
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
#Btru <- ps(T, df = p)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n), c(rep(0, n/2), rep(1,n/2)))
#X <- cbind(rep(1,n),runif(n,min=-1,max=1))
#X <- cbind(rep(1,n), rnorm(n, sd = 1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda1 <- L1[,1]
#Lambda2 <- L2[,1]
Lambda1 <-  10*L1
Lambda2 <-  10*L2
#Theta1 <- Theta[,1]
Theta1 <- 1*Theta
#X <- as.matrix(X[,1])
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
noise_sd <- .1
E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
Y <- X%*%t(Theta1)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
set.seed(2)
p <- 12
#B <- bs(T, df = p, intercept = TRUE)
B <- ps(T, df = p, diff = 1, intercept = TRUE)
K <- 2
Xmat <- kronecker(B, X)
reg <- lm(c(Y) ~ Xmat - 1)
Theta_init <- t(matrix(reg$coefficients, nrow = 2))
param <- cpp_EM(X, B, Y, K, Theta_init, p)
print(c("log likelihood to beat is", cpploglik(Theta1, cbind(Lambda1,Lambda2), 1/noise_sd^2, X, Btru, Y, 2, 6)))
# EM initialization
{
Theta_init <- param$Theta
Lambda_init <- array(param$Lambda, dim = c(p, 2, K))
Eta_init <- t(param$EtaM)
Prec_init <- param$Precision
}
x <- c(1,0)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
# EM initialization
{
Theta_init <- param$Theta
Lambda_init <- array(param$Lambda, dim = c(p, 2, K))
Eta_init <- t(param$EtaM)
Prec_init <- param$Precision
}
max_iter <- 1000
burnin <- 100
thin <- 1
nchain <- 1
set.seed(2)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,0)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
cov1 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1
for(a in 1:K){
cov1 <- cov1 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov2 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1000
for(a in 1:K){
cov2 <- cov2 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov3 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 500
for(a in 1:K){
cov3 <- cov3 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
dev.off()
persp3D(1:tmax,1:tmax, cov1, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov2, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov3, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
subj <- 2
iter <- 1000
plot(Y[subj,],type="p")
lines(B%*%param$Theta%*%X[subj,] + B%*%param$Lambda[,1:2]%*%X[subj,] * param$EtaM[1,subj] +
B%*%param$Lambda[,3:4]%*%X[subj,] * param$EtaM[2,subj],col="blue")
lines(B%*%bayes_param$Theta[[1]][,,iter]%*%X[subj,] + bayes_param$Eta[[1]][subj,1,iter] * B%*%bayes_param$Lambda[[1,iter]][,,1]%*%X[subj,]+
bayes_param$Eta[[1]][subj,2,iter] * B%*%bayes_param$Lambda[[1,iter]][,,2]%*%X[subj,], col = "red")
sapply(burnin:max_iter, function(iter) lines(B%*%bayes_param$Theta[[1]][,,iter]%*%X[subj,] + bayes_param$Eta[[1]][subj,1,iter] * B%*%bayes_param$Lambda[[1,iter]][,,1]%*%X[subj,]+
bayes_param$Eta[[1]][subj,2,iter] * B%*%bayes_param$Lambda[[1,iter]][,,2]%*%X[subj,], col="gray"))
x <- c(1,1)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
cov1 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1
for(a in 1:K){
cov1 <- cov1 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov2 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 1000
for(a in 1:K){
cov2 <- cov2 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov3 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 500
for(a in 1:K){
cov3 <- cov3 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
dev.off()
persp3D(1:tmax,1:tmax, cov1, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov2, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov3, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
library(BayesianConditionalFPCA)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,1)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
library(BayesianConditionalFPCA)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,1)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
bayes_param$Tau[[1]][,,1000]
library(BayesianConditionalFPCA)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,1)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim = c(1, 2))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 1)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in burnin:max_iter){
for(a in 1:K){
covbayes <- covbayes + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
}
}
covbayes <- covbayes / ((max_iter - burnin + 1) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE)
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
exp(-1)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0000001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
library(BayesianConditionalFPCA)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
exp(-1)
exp(-.9)
exp(-.8)
library(BayesianConditionalFPCA)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
library(BayesianConditionalFPCA)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .005)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0025)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
sd(bayes_param$Eta[[1]][,1,100])
sd(bayes_param$Eta[[1]][,1,200])
