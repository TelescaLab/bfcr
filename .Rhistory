# EM initialization
{
Theta_init <- param$Theta
Lambda_init <- array(param$Lambda, dim = c(p, 2, K))
Eta_init <- t(param$EtaM)
Prec_init <- param$Precision
}
max_iter <- 30000
burnin <- 15000
thin <- 1
nchain <- 1
set.seed(1)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,-.5)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim=c(1.20, 1.75))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 10)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
L <- numeric(max_iter)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in 1:max_iter){
covbayesp <- B%*%diag(1/bayes_param$Delta[[chain]][,iter])%*%t(B)
for(a in 1:K){
covbayesp <- covbayesp + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
covbayes <- covbayesp + covbayes
L[iter + max_iter*(chain-1)] <- covbayesp[1429]
}
}
plot(L, type = "l")
covbayes <- covbayes / ((max_iter - 0) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE,zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
x <- c(1,.5)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim=c(1.20, 1.75))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 10)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
L <- numeric(max_iter)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in 1:max_iter){
covbayesp <- B%*%diag(1/bayes_param$Delta[[chain]][,iter])%*%t(B)
for(a in 1:K){
covbayesp <- covbayesp + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
covbayes <- covbayesp + covbayes
L[iter + max_iter*(chain-1)] <- covbayesp[1429]
}
}
plot(L, type = "l")
covbayes <- covbayes / ((max_iter - 0) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE,zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
dev.off()
cov1 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 10000
for(a in 1:K){
cov1 <- cov1 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov2 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 12500
for(a in 1:K){
cov2 <- cov2 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
cov3 <- matrix(0, nrow = tmax, ncol = tmax)
iter <- 15000
for(a in 1:K){
cov3 <- cov3 + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
persp3D(1:tmax,1:tmax, cov1, theta=90,phi=10, main = "Truth", colkey = FALSE, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
persp3D(1:tmax,1:tmax, cov2, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, cov3, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
dev.off()
subj <- 4
iter <- 400
plot(Y[subj,],type="p")
lines(B%*%param$Theta%*%X[subj,] + B%*%param$Lambda[,1:2]%*%X[subj,] * param$EtaM[1,subj] +
B%*%param$Lambda[,3:4]%*%X[subj,] * param$EtaM[2,subj],col="blue")
#lines(B%*%bayes_param$Theta[[1]][,,iter]%*%X[subj,] + bayes_param$Eta[[1]][subj,1,iter] * B%*%bayes_param$Lambda[[1,iter]][,,1]%*%X[subj,]+
#       bayes_param$Eta[[1]][subj,2,iter] * B%*%bayes_param$Lambda[[1,iter]][,,2]%*%X[subj,], col = "red")
#lines(B%*%bayes_param$Proj[[1]][subj,,iter],col="green")
lines(B%*%rowMeans(bayes_param$Proj[[1]][subj,,burnin:max_iter]), col = "red")
Ycol <- c(t(Y))
B_est <- B
dim(B_est)
num_basis_est<-12
N
N <- 200
data1 = list(N = N, num_basis = num_basis_est, t = tmax, Y = Ycol, X = X, B = B_est, K = 2)
reg <- lm(Ycol ~ kronecker(X, B_est)-1)
init <- list(list(a = matrix(reg$coefficients, ncol = 2)))
fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv", "phi_inv_sqrt", "projectionp"), tol_rel_obj = 0.01)
library(dlnm)
library(rstan)
options(mc.cores =parallel::detectCores())
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=core2')
set.seed(3)
m <- stan_model(model_code = splines)
splines <- "
data{
int<lower=0> N; // Number of samples
int<lower=0> num_basis; // Dimension of basis matrix
int<lower=0> d; // Number of covariates
int<lower=0> t; // number of time points
vector[t * N] Y;
matrix[N,2] X;
matrix[t, num_basis] B;
int<lower=0> K;
}
parameters{
matrix[num_basis,2] a;
real<lower=0> precision;
vector[N] Z[K];
matrix[num_basis, 2] Lam[K];
matrix<lower=0>[2, 2] smooth_inv;
vector<lower=0>[num_basis] phi;
vector[N * num_basis] projectionp;
}
transformed parameters{
vector[t * N] Y_hat;
real<lower=0> sigma;
vector<lower=0>[num_basis] phi_inv_sqrt;
matrix<lower=0>[2, 2] smooth;
vector[num_basis * N] projection;
projection = to_vector(a*X');
for(k in 1:K){
projection = projection + to_vector(Lam[k]*X'*diag_matrix(Z[k]));
}
sigma = inv(sqrt(precision));
for(j in 1:num_basis){
phi_inv_sqrt[j] = 1 / sqrt(phi[j]);
}
//phi_inv_sqrt = 1 ./ sqrt(phi);
smooth = 1 ./ smooth_inv;
}
model{
precision ~ gamma(.0001, .0001);
to_vector(phi) ~ gamma(1, .5);
for(k in 1:K){
Z[k] ~ normal(0,1);
}
to_vector(smooth_inv) ~ gamma(1, .00005);
for(k in 1:K){
for(i in 1:num_basis){
for(j in 1:2){
if(i == 1){
Lam[k, i, j] ~ normal(0, smooth[2,j]);
a[i, j] ~ normal(0, smooth[1,j]);
}
else if(i == 2){
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j], smooth[1,j]);
}
else {
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j] - Lam[k,i-2,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j] - a[i-2,j], smooth[1,j]);
}
}
}
}
for(i in 1:N){
for(j in 1:num_basis){
projectionp[((i-1) * num_basis + j)] ~ normal(projection[((i-1) * num_basis + j)], phi_inv_sqrt[j]);
}
}
for(i in 1:N){
Y[(i-1) * t + 1:(t * i)] ~ normal(B * projectionp[((i-1) * num_basis + 1):(num_basis * i)], sigma);
}
}
"
m <- stan_model(model_code = splines)
fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv", "phi_inv_sqrt", "projectionp"), tol_rel_obj = 0.01)
splines <- "
data{
int<lower=0> N; // Number of samples
int<lower=0> num_basis; // Dimension of basis matrix
int<lower=0> t; // number of time points
vector[t * N] Y;
matrix[N,2] X;
matrix[t, num_basis] B;
int<lower=0> K;
}
parameters{
matrix[num_basis,2] a;
real<lower=0> precision;
vector[N] Z[K];
matrix[num_basis, 2] Lam[K];
matrix<lower=0>[2, 2] smooth_inv;
vector<lower=0>[num_basis] phi;
vector[N * num_basis] projectionp;
}
transformed parameters{
vector[t * N] Y_hat;
real<lower=0> sigma;
vector<lower=0>[num_basis] phi_inv_sqrt;
matrix<lower=0>[2, 2] smooth;
vector[num_basis * N] projection;
projection = to_vector(a*X');
for(k in 1:K){
projection = projection + to_vector(Lam[k]*X'*diag_matrix(Z[k]));
}
sigma = inv(sqrt(precision));
for(j in 1:num_basis){
phi_inv_sqrt[j] = 1 / sqrt(phi[j]);
}
//phi_inv_sqrt = 1 ./ sqrt(phi);
smooth = 1 ./ smooth_inv;
}
model{
precision ~ gamma(.0001, .0001);
to_vector(phi) ~ gamma(1, .5);
for(k in 1:K){
Z[k] ~ normal(0,1);
}
to_vector(smooth_inv) ~ gamma(1, .00005);
for(k in 1:K){
for(i in 1:num_basis){
for(j in 1:2){
if(i == 1){
Lam[k, i, j] ~ normal(0, smooth[2,j]);
a[i, j] ~ normal(0, smooth[1,j]);
}
else if(i == 2){
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j], smooth[1,j]);
}
else {
Lam[k, i, j] ~ normal(2*Lam[k, i-1,j] - Lam[k,i-2,j], smooth[2,j]);
a[i, j] ~ normal(2*a[i-1,j] - a[i-2,j], smooth[1,j]);
}
}
}
}
for(i in 1:N){
for(j in 1:num_basis){
projectionp[((i-1) * num_basis + j)] ~ normal(projection[((i-1) * num_basis + j)], phi_inv_sqrt[j]);
}
}
for(i in 1:N){
Y[(i-1) * t + 1:(t * i)] ~ normal(B * projectionp[((i-1) * num_basis + 1):(num_basis * i)], sigma);
}
}
"
m <- stan_model(model_code = splines)
fitvb <- vb(m, data = data1, algorithm = "meanfield",  init = init[[1]], iter = 200000, par = c("a", "Lam", "Z", "sigma", "smooth_inv", "phi_inv_sqrt", "projectionp"), tol_rel_obj = 0.01)
posterior <- extract(fitvb)
subj <- 2
plot(tp,Ycol[((subj-1) * tmax + 1):(subj*tmax)])
tp <- seq(from=0, to=1, length.out = tmax) # generating inputs
subj <- 2
plot(tp,Ycol[((subj-1) * tmax + 1):(subj*tmax)])
for(i in 1:50){
lines(tp, B_est%*%posterior$projectionp[i, ((subj-1) * num_basis_est + 1):(subj*num_basis_est)], col = "gray")
}
lines(tp,c(Y_true)[((subj-1) * tmax + 1):(subj*tmax)], col = "red")
x <- c(1,-.5)
cov_true <- B_true%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(B_true) + B_true%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(B_true)
cov_est <- matrix(0,nrow = length(tp), ncol = length(tp))
for(i in 1:1000){
cov_est <- B_est%*%diag(posterior$phi_inv_sqrt[i,])%*%t(B_est) + cov_est
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
j <- 10
cov1 <- B_est%*%diag(posterior$phi_inv_sqrt[j,])%*%t(B_est)
for(k in 1:K){
cov1 <- B_est%*%posterior$Lam[j,k,,]%*%outer(x,x)%*%t(posterior$Lam[j,k,,])%*%t(B_est) + cov1
}
library(plot3D)
par(mfrow = c(1,3))
persp3D(tp,tp, cov_est, phi = 10, theta = 90, zlim = c(min(cov_true), max(cov_true)))
cov_true <- B_true%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(B_true) + B_true%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(B_true)
B_true <- B
cov_true <- B_true%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(B_true) + B_true%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(B_true)
cov_est <- matrix(0,nrow = length(tp), ncol = length(tp))
for(i in 1:1000){
cov_est <- B_est%*%diag(posterior$phi_inv_sqrt[i,])%*%t(B_est) + cov_est
for(k in 1:K){
cov_est <- B_est%*%posterior$Lam[i,k,,]%*%outer(x,x)%*%t(posterior$Lam[i,k,,])%*%t(B_est) + cov_est
}
}
cov_est <- cov_est / 1000
j <- 10
cov1 <- B_est%*%diag(posterior$phi_inv_sqrt[j,])%*%t(B_est)
for(k in 1:K){
cov1 <- B_est%*%posterior$Lam[j,k,,]%*%outer(x,x)%*%t(posterior$Lam[j,k,,])%*%t(B_est) + cov1
}
library(plot3D)
par(mfrow = c(1,3))
persp3D(tp,tp, cov_est, phi = 10, theta = 90, zlim = c(min(cov_true), max(cov_true)))
par(mfrow = c(1,3))
persp3D(tp,tp, cov_est, phi = 10, theta = 90, zlim = c(min(cov_true), max(cov_true)))
persp3D(tp,tp, cov_true, phi = 10, theta = 90, zlim = c(min(cov_true), max(cov_true)))
persp3D(tp,tp, cov1, phi = 10, theta = 90, zlim = c(min(cov_true), max(cov_true)))
dev.off()
plot(B_true%*%alpha%*%x,type="l",col="red")
alpha <- Theta1
plot(B_true%*%alpha%*%x,type="l",col="red")
for(i in 1:1000){
lines(B_est%*%posterior$a[i,,]%*%x,col="gray")
}
lines(B_true%*%alpha%*%x,type="l",col="red")
?seq_along
apply(posterior$Lam, 1, mean)
apply(posterior$Lam, c(2,3,4), mean)
Lambda_init <- apply(posterior$Lam, c(2,3,4), mean)
dim(Lambda_init)
Lambda_init <- array(apply(posterior$Lam, c(2,3,4), mean),dim=c(12,2,2))
Lambda_init
Lambda_init <- array(apply(t(posterior$Lam), c(2,3,4), mean),dim=c(12,2,2))
Lambda_init <- array(t(apply(posterior$Lam, c(2,3,4), mean),dim=c(12,2,2)))
Lambda_init <- array(t(apply(posterior$Lam, c(2,3,4), mean)),dim=c(12,2,2))
Lambda_init <- array(0, dim=c(p, dim(X)[2], K))
Lambda_init <- array(0, dim=c(p, dim(X)[2], K))
apply(posterior$Lam,c(2,3,4),mean)
apply(posterior$Lam,c(2,3,4),mean)[k,,]
posterior$Lam[100,1,,]
Theta_init <- apply(posterior$a, c(2,3), mean)
Theta_init
dim(posterior$Z)
Eta_init <- apply(posterior$Z, c(2,3), mean)
Eta_init
Eta_init <- apply(posterior$Z, c(2,3), mean)
dim(Eta_init)
dim(bayes_param$Eta[[1]][,,10])
Prec_init <- mean(1/posterior$sigma^2)
Prec_init
max_iter <- 30000
burnin <- 15000
thin <- 1
nchain <- 1
set.seed(1)
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .0015)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
Theta_init
Lambda_init
for(k in 1:K){
Lambda_init[,,k] <- apply(posterior$Lam,c(2,3,4),mean)[k,,]
}
Lambda_init
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
Eta_init
dim(Eta_init)
dim(bayes_param$Eta[[1]][,,10])
Eta_init <- t(apply(posterior$Z, c(2,3), mean))
dim(Eta_init)
bayes_param <- MCMC(Y, X, B, K, max_iter, nchain, thin, .001, 100, Theta_init, Lambda_init, Eta_init, Prec_init)
L <- sapply(1:max_iter, function(i)bayes_param$Lambda[[1,i]][3,1,1])
plot(L, type = "l")
find_stepsize(Y, Theta_init, Lambda_init, Prec_init, X, B, .001)
dev.off()
x <- c(1,.5)
bayes_mean <- matrix(0, nrow = p, ncol = 2)
for(i in 1:nchain){
bayes_mean <- bayes_mean + apply(bayes_param$Theta[[i]][,,burnin:max_iter], c(1,2), mean)
}
bayes_mean <- bayes_mean / nchain
plot(T,Btru%*%Theta1%*%x, type = "l", ylab = "Mean, x = -0.5", xlab = "t", ylim=c(1.20, 1.75))
lines(T,B%*%Theta_init%*%x,col="green")
lines(T,B%*%param$Theta%*%x, col = "blue")
lines(T,B%*%bayes_mean%*%x, col = "red")
for(chain in 1:nchain){
for(i in seq(from = burnin, to = max_iter, by = 10)){
lines(T,B%*%bayes_param$Theta[[chain]][,,i]%*%x, col = "gray")
}
}
lines(T,Btru%*%Theta1%*%x,col="red")
sum((B%*%param$Theta%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
sum((B%*%bayes_mean%*%x - Btru%*%Theta1%*%x)^2)/sum((Btru%*%Theta1%*%x)^2)*100
covfreq <- matrix(0, p, p)
for(k in 1:K){
covfreq <- covfreq + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covfreq <- B%*%covfreq%*%t(B)
L <- numeric(max_iter)
covbayes <- matrix(0, nrow = tmax, ncol = tmax)
for(chain in 1:nchain){
for(iter in 1:max_iter){
covbayesp <- B%*%diag(1/bayes_param$Delta[[chain]][,iter])%*%t(B)
for(a in 1:K){
covbayesp <- covbayesp + B%*%bayes_param$Lambda[[chain,iter]][,,a]%*%outer(x,x)%*%t(bayes_param$Lambda[[chain,iter]][,,a])%*%t(B)
}
covbayes <- covbayesp + covbayes
L[iter + max_iter*(chain-1)] <- covbayesp[1429]
}
}
plot(L, type = "l")
covbayes <- covbayes / ((max_iter - 0) * nchain)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covfreq - covtruth)^2)/sum((covtruth)^2)*100
sum((covbayes - covtruth)^2)/sum((covtruth^2))*100
par(mfrow = c(1,3))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10, main = "Truth", colkey = FALSE,zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
persp3D(1:tmax,1:tmax, covfreq, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "EM algorithm", colkey = FALSE)
persp3D(1:tmax,1:tmax, covbayes, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))), main = "Gibbs sampling", colkey = FALSE)
P <- create_partition(NodeGraph,50)
create_partition <- function(G, K = 50){
vertex_attr(NodeGraph) <- list(name = as.character(1:length(V(NodeGraph))))
remaining <- 1:length(V(NodeGraph))
partition <- matrix("0", nrow = K, ncol = length(V(NodeGraph)))
current <- 1
iter <- 1
while(length(remaining) > K){
myorder <- 1
v <- intersect(ego(NodeGraph, order = myorder, current)[[1]], remaining)
while(length(v) < K){
myorder <- myorder + 1
v <- intersect(ego(NodeGraph, order = myorder, current)[[1]], remaining)
}
partition[,current] <- V(NodeGraph)$name[v[1:K]]
remaining <- remaining[!remaining %in% v[1:K]]
current <- min(remaining)
iter <- iter + 1
}
partition <- cbind(partition, c(remaining, rep(NA, K-length(remaining))))
storage.mode(partition) <- "numeric"
partition <- partition[,which(partition[1,] != 0)]
return(partition)
}
P <- create_partition(NodeGraph,50)
create_macro_graph <- function(P){
#M <- Matrix(0, nrow = dim(P)[2], ncol = dim(P)[2], sparse = TRUE)
M <- graph.adjacency(matrix(0, dim(P)[2], dim(P)[2]))
first_na <- which(is.na(P[,dim(P)[2]]))[1]
K <- dim(P)[1]
for(i in 1:dim(P)[2]){
if(i == dim(P)[2]){
ind <- unique(floor(which(P %in% unlist(ego(NodeGraph, nodes = P[1:(first_na-1),i], mode="out")))/K+1))
}
else{
ind <- unique(floor(which(P %in% unlist(ego(NodeGraph, nodes = P[,i], mode="out")))/K+1))
}
M <- add.edges(M, c(rbind(rep(i, length(ind)), ind)))
}
return(simplify(M))
}
M <- create_macro_graph(P)
A  <- arma_sim_partition(G, nu, 50, P, M, str = .4, noise = .1)
G
nu
P
M
sourceCpp("ErrorPropC.cpp")
A  <- arma_sim_partition(G, nu, 50, P, M, str = .4, noise = .1)
y <- colMeans(A$Dat_part)[1:(320*320)]
x1 <- rep(1:320, each = 320)
x2 <- rep(1:320, times = 320)
x_mat <- cbind(x1, x2)
x <- 1:102737
lo <- loess(y~x_mat, span = .005)
image(seq(from = 0, to = 1, length.out = 320), seq(from = 0, to = 1, length.out = 320), (matrix(lo$fitted[1:(320*320)],ncol = 320))[,320:1], col = colfunc(1000), xlab = "X", ylab = "Y", main = expression(atop("High dispersion, High connectivity ", lambda*" = 5, " *beta* " = .1", "Reconstruction after partitioning")))
dev.off()
image(seq(from = 0, to = 1, length.out = 320), seq(from = 0, to = 1, length.out = 320), (matrix(lo$fitted[1:(320*320)],ncol = 320))[,320:1], col = colfunc(1000), xlab = "X", ylab = "Y", main = expression(atop("High dispersion, High connectivity ", lambda*" = 5, " *beta* " = .1", "Reconstruction after partitioning")))
image(seq(from = 0, to = 1, length.out = 320), seq(from = 0, to = 1, length.out = 320), (matrix(lo$fitted[1:(320*320)],ncol = 320))[,320:1], col = colfunc(1000), xlab = "X", ylab = "Y", main = expression(atop("High dispersion, High connectivity, Reconstruction after partitioning ", lambda*" = 5, " *beta* " = .1", )))
image(seq(from = 0, to = 1, length.out = 320), seq(from = 0, to = 1, length.out = 320), (matrix(lo$fitted[1:(320*320)],ncol = 320))[,320:1], col = colfunc(1000), xlab = "X", ylab = "Y", main = expression(atop("High dispersion, High connectivity, Reconstruction after partitioning ", lambda*" = 5, " *beta* " = .1","hd" )))
image(seq(from = 0, to = 1, length.out = 320), seq(from = 0, to = 1, length.out = 320), (matrix(lo$fitted[1:(320*320)],ncol = 320))[,320:1], col = colfunc(1000), xlab = "X", ylab = "Y", main = expression(atop("High dispersion, High connectivity, Reconstruction after partitioning ", lambda*" = 5, " *beta* " = .1")))
