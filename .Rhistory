(mean - eigvec)^2)) == 1 ~ -eigvec, TRUE ~ eigvec))
results[15:16] <- 100 * unlist((eigen_bands_tibble %>%
group_by(number) %>%
summarize(RISE = trapz(t, (mean - eigvec)^2) / trapz(t, eigvec^2)))[,2]) +
results[15:16]
results[17:18] <- unlist((eigen_bands_tibble %>%
group_by(number) %>%
filter(eigvec >= lower & eigvec <= upper) %>%
summarize(coverage = 100 * n() / tmax))[,2]) + results[17:18]
results[19:20] <- unlist((eigen_bands_tibble %>%
group_by(number) %>%
summarize(mean_l = mean(upper - lower)))[,2]) + results[19:20]
results[21] <- trapz(t,sapply(1:tmax, function(i) trapz(t, (eigen_bands$surface[,i] -
truecov[,i])^2))) / trapz(t, sapply(1:tmax, function(i) trapz(t,
truecov[,i]^2))) * 100 + results[21]
print(100 * trapz(t,sapply(1:tmax, function(i) trapz(t, (eigen_bands$surface[,i] -
truecov[,i])^2))) / trapz(t, sapply(1:tmax, function(i) trapz(t,
truecov[,i]^2))))
# results[22] <- trapz(t,sapply(1:tmax, function(i) trapz(t, (eigen_bands$surface_cor[,i] -
#                                                               cov2cor(truecov)[,i])^2))) / trapz(t, sapply(1:tmax, function(i) trapz(t,
#                                                                                                                             cov2cor(truecov)[,i]^2))) * 100 + results[22]
}
results[15:21] <- results[15:21] / length(Age_seq)
idx <- 11
evals <- 2
zi <- new_points[idx,]
zim <- c(1, Age_seq[idx])
#zi <- c(1, Age_seq[10])
#truecov <- tcrossprod(lbasis1_int) + tcrossprod(lbasis2_int)
truecov <- basis1_fn %*% outer(zim, zim) %*% t(basis1_fn) +
basis2_fn %*% outer(zim, zim) %*% t(basis2_fn)
eigen_bands <- get_posterior_eigen2(mcmc_results, evals, zi, alpha)
persp3D(1:50,1:50, truecov)
persp3D(1:50,1:50, eigen_bands$surface)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
matlist <- list()
matlist[[1]] <- TBasis$S[[1]]
matlist[[2]] <- TBasis$S[[1]]
mcmc_results <- run_mcmc_Morris_Tensor(Y, t, X, X, TBasis$X,
matlist, matlist, c(1,2), c(1,2),
K = 2, iter = 20000,
burnin = 20000, nchains = 1,
thin = 1, loglik = 0)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
print_n_unique(2, matlist, matlist, c(1,2), c(1,2), matlist[[1]])
matlist[[1]]
matlist <- list()
matlist <- list()
matlist[[1]] <- PP1
matlist[[2]] <- PP2
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
#   truecov <- matrix(0, nrow = tmax, ncol = tmax)
#   truecov <- Btru %*% Lambda1 %*% outer(zi, zi) %*% t(Lambda1) %*% t(Btru) +
#     Btru %*% Lambda2 %*% outer(zi, zi) %*% t(Lambda2) %*% t(Btru)
#   Cov_mat[counter] <- sum(eigen(truecov)$values)
#   counter <- counter + 1
# }
# plot(Cov_mat,type="l")
# plot(Cov_mat[,1], type = "l")
# lines(Cov_mat[,3])
library(spam)
Age <- X[,2]
TBasis <- smooth.construct(s(t, bs = "ps", k = 12), data.frame(t), NULL)
# setwd("/u/home/j/jshamsh1/Documents/BayesianConditionalFPCA_results")
# files_in_dir <- dir()
# numbers_to_run <- which(!(paste0("N100Full", 1:500, ".RData") %in% files_in_dir))
# seed <- numbers_to_run[as.numeric(args)]
seed <- as.numeric(args)
set.seed(seed)
library(splines)
library(MASS)
# library(plot3D)
library(dlnm)
library(BayesianConditionalFPCA)
# library(rstan)
# library(loo)
library(tidyverse)
library(pracma)
library(mgcv)
n <- 50
tmax <- 50
t <- seq(from = 0, to = 1, length.out = tmax)
p <- 12
B <- bs(t, df = p, intercept = TRUE)
int_function <- 1*(t-.5*t^2)
x_function <- t*sin(2*pi*t)
#x_function <- .2*sqrt(t)
lbasis1_int <- .2*(1-1*(t-.5)^2)
#lbasis1_int <- rep(0, length(t))
#lbasis1_int <- .25*cos(t*pi)
lbasis2_int <- .25*sin(t*pi)
lbasis1_z <- .25*exp(cos(t))
lbasis2_z <- .25*exp(sin(t))
#lbasis1_z <- rep(0, length(t))
X <- cbind(rep(1,n), rnorm(n, sd = 1))
Age <- X[,2]
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 10), data.frame(Age), NULL)
noise_sd <- .1
# E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
E <- matrix(0, nrow = n, ncol = tmax)
for(i in 1:n){
# E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd + (i %% 5) * noise_sd / 5)
E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd)
}
mean_fn <- cbind(int_function, x_function)
mean_grid <- cbind(int_function, x_function) %*% t(X)
basis1_fn <- cbind(lbasis1_int, lbasis1_z)
basis2_fn <- cbind(lbasis2_int, lbasis2_z)
basis1_grid <- cbind(lbasis1_int, lbasis1_z) %*% t(X)
basis2_grid <- cbind(lbasis2_int, lbasis2_z) %*% t(X)
Eta1 <- rnorm(n, sd = sqrt(1))
Eta2 <- rnorm(n, sd = sqrt(1))
Y_mean <- t(mean_grid)
Y_no_error <-  t(mean_grid) + diag(Eta1)%*%t(basis1_grid) + diag(Eta2)%*%t(basis2_grid)
Y <- Y_no_error + E
#####################################################################
########################## MCMC #####################################
#####################################################################
K <- 4
Basis <- ps(t, df = 16, intercept = TRUE)
library(spam)
Age <- X[,2]
TBasis <- smooth.construct(s(t, bs = "ps", k = 12), data.frame(t), NULL)
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 4), data.frame(Age), NULL)
DT <- as.matrix(diff.spam(diag.spam(12), lag = 1, differences = 2))
DAge <- as.matrix(diff.spam(diag.spam(4), lag = 1, differences = 2))
P1 <- t(DT)%*%DT
P2 <- t(DAge) %*% DAge
PP1 <- kronecker(t(DAge)%*%DAge, diag(12))
PP2 <- kronecker(diag(4), t(DT)%*%DT)
Q <- precmat.IGMRFreglat(12, 4, order = 2)
matlistmean <- list()
matlistmean[[1]] <- as.matrix(Q)
matlistvar <- list()
matlistvar[[1]] <- as.matrix(Q)
print_n_unique(2, matlistmean, matlistvar, c(1,2), c(1,2), matlist[[1]])
print_n_unique(2, matlistmean, matlistvar, c(1,2), c(1,2), TBasis$X)
devtools::document()
print_n_unique(2, matlistmean, matlistvar, c(1,2), c(1,2), TBasis$X)
devtools::document()
devtools::document()
devtools::document()
print_n_unique(2, matlistmean, matlistvar, c(1,2), c(1,2), TBasis$X)
devtools::document()
print_n_unique(2, matlistmean, matlistvar, c(1,2), c(1,2), TBasis$X)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(splines)
library(MASS)
# library(plot3D)
library(dlnm)
library(BayesianConditionalFPCA)
# library(rstan)
# library(loo)
library(tidyverse)
library(pracma)
library(mgcv)
#####################################################################
################### MEAN AND VARIANCE FUNCTIONS #####################
#####################################################################
n <- 500
tmax <- 100
t <- seq(from = 0, to = 1, length.out = tmax)
p <- 12
B <- bs(t, df = p, intercept = TRUE)
int_function <- 1*(t-.5*t^2)
x_function <- t*sin(2*pi*t)
#x_function <- .2*sqrt(t)
lbasis1_int <- .2*(1-1*(t-.5)^2)
#lbasis1_int <- rep(0, length(t))
#lbasis1_int <- .25*cos(t*pi)
lbasis2_int <- .25*sin(t*pi)
lbasis1_z <- .25*exp(cos(t))
lbasis2_z <- .25*exp(sin(t))
#lbasis1_z <- rep(0, length(t))
#lbasis2_z <- rep(0, length(t))
#####################################################################
####################### DATA GENERATION #############################
#####################################################################
X <- cbind(rep(1,n), rnorm(n, sd = 1))
Age <- X[,2]
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 10), data.frame(Age), NULL)
noise_sd <- .1
# E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
E <- matrix(0, nrow = n, ncol = tmax)
for(i in 1:n){
# E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd + (i %% 5) * noise_sd / 5)
E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd)
}
mean_fn <- cbind(int_function, x_function)
mean_grid <- cbind(int_function, x_function) %*% t(X)
basis1_fn <- cbind(lbasis1_int, lbasis1_z)
basis2_fn <- cbind(lbasis2_int, lbasis2_z)
basis1_grid <- cbind(lbasis1_int, lbasis1_z) %*% t(X)
basis2_grid <- cbind(lbasis2_int, lbasis2_z) %*% t(X)
Eta1 <- rnorm(n, sd = sqrt(1))
Eta2 <- rnorm(n, sd = sqrt(1))
Y_mean <- t(mean_grid)
Y_no_error <-  t(mean_grid) + diag(Eta1)%*%t(basis1_grid) + diag(Eta2)%*%t(basis2_grid)
Y <- Y_no_error + E
Z <- cbind(rep(1, n))
library(spam)
Age <- X[,2]
TBasis <- smooth.construct(s(t, bs = "ps", k = 12), data.frame(t), NULL)
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 4), data.frame(Age), NULL)
Q <- precmat.IGMRFreglat(12, 4, order = 2)
matlistmean <- list()
matlistmean[[1]] <- as.matrix(Q)
matlistvar <- list()
matlistvar[[1]] <- as.matrix(Q)
pars <- my_main(Y, X, X, TBasis$X, 4, matlistmean,
matlistvar, c(1), c(1))
pars$Beta
pars$Lambda
pars$Eta
dim(pars$Eta)
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
dim(pars$Eta)
pars$Eta
library(splines)
library(MASS)
# library(plot3D)
library(dlnm)
library(BayesianConditionalFPCA)
# library(rstan)
# library(loo)
library(tidyverse)
library(pracma)
library(mgcv)
#####################################################################
################### MEAN AND VARIANCE FUNCTIONS #####################
#####################################################################
n <- 500
tmax <- 100
t <- seq(from = 0, to = 1, length.out = tmax)
p <- 12
B <- bs(t, df = p, intercept = TRUE)
int_function <- 1*(t-.5*t^2)
x_function <- t*sin(2*pi*t)
#x_function <- .2*sqrt(t)
lbasis1_int <- .2*(1-1*(t-.5)^2)
#lbasis1_int <- rep(0, length(t))
#lbasis1_int <- .25*cos(t*pi)
lbasis2_int <- .25*sin(t*pi)
lbasis1_z <- .25*exp(cos(t))
lbasis2_z <- .25*exp(sin(t))
#lbasis1_z <- rep(0, length(t))
#lbasis2_z <- rep(0, length(t))
#####################################################################
####################### DATA GENERATION #############################
#####################################################################
X <- cbind(rep(1,n), rnorm(n, sd = 1))
Age <- X[,2]
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 10), data.frame(Age), NULL)
noise_sd <- 1
# E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
E <- matrix(0, nrow = n, ncol = tmax)
for(i in 1:n){
# E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd + (i %% 5) * noise_sd / 5)
E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd)
}
mean_fn <- cbind(int_function, x_function)
mean_grid <- cbind(int_function, x_function) %*% t(X)
basis1_fn <- cbind(lbasis1_int, lbasis1_z)
basis2_fn <- cbind(lbasis2_int, lbasis2_z)
basis1_grid <- cbind(lbasis1_int, lbasis1_z) %*% t(X)
basis2_grid <- cbind(lbasis2_int, lbasis2_z) %*% t(X)
Eta1 <- rnorm(n, sd = sqrt(1))
Eta2 <- rnorm(n, sd = sqrt(1))
Y_mean <- t(mean_grid)
Y_no_error <-  t(mean_grid) + diag(Eta1)%*%t(basis1_grid) + diag(Eta2)%*%t(basis2_grid)
Y <- Y_no_error + E
Z <- cbind(rep(1, n))
library(spam)
Age <- X[,2]
TBasis <- smooth.construct(s(t, bs = "ps", k = 12), data.frame(t), NULL)
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 4), data.frame(Age), NULL)
Q <- precmat.IGMRFreglat(12, 4, order = 2)
matlistmean <- list()
matlistmean[[1]] <- as.matrix(Q)
matlistvar <- list()
matlistvar[[1]] <- as.matrix(Q)
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
pars$Eta[1,]
pars$Eta[2,]
pars$Lambda[,,1]
pars$Lambda[,,2]
pars$Lambda[,,3]
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
pars$Lambda
pars$Beta
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
pars$Eta[1,]
pars$Eta[2,]
pars$Beta
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
pars$Eta[1,]
pars$Eta[2,]
pars$Eta[3,]
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
pars$Eta[1,]
pars$Eta[2,]
pars$Eta[3,]
### Sanity check
plot(Y[1,])
### Sanity check
plot(Y[1,], type = "l")
X <- cbind(rep(1,n), rnorm(n, sd = 1))
Age <- X[,2]
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 10), data.frame(Age), NULL)
noise_sd <- .1
# E <- matrix(rnorm(tmax * n,sd=noise_sd), nrow = n, ncol = tmax)
E <- matrix(0, nrow = n, ncol = tmax)
for(i in 1:n){
# E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd + (i %% 5) * noise_sd / 5)
E[i, ] <- rnorm(tmax, mean = 0, sd = noise_sd)
}
mean_fn <- cbind(int_function, x_function)
mean_grid <- cbind(int_function, x_function) %*% t(X)
basis1_fn <- cbind(lbasis1_int, lbasis1_z)
basis2_fn <- cbind(lbasis2_int, lbasis2_z)
basis1_grid <- cbind(lbasis1_int, lbasis1_z) %*% t(X)
basis2_grid <- cbind(lbasis2_int, lbasis2_z) %*% t(X)
Eta1 <- rnorm(n, sd = sqrt(1))
Eta2 <- rnorm(n, sd = sqrt(1))
Y_mean <- t(mean_grid)
Y_no_error <-  t(mean_grid) + diag(Eta1)%*%t(basis1_grid) + diag(Eta2)%*%t(basis2_grid)
Y <- Y_no_error + E
Z <- cbind(rep(1, n))
library(spam)
Age <- X[,2]
TBasis <- smooth.construct(s(t, bs = "ps", k = 12), data.frame(t), NULL)
AgeBasis <- smooth.construct(s(Age, bs = "ps", k = 4), data.frame(Age), NULL)
Q <- precmat.IGMRFreglat(12, 4, order = 2)
matlistmean <- list()
matlistmean[[1]] <- as.matrix(Q)
matlistvar <- list()
matlistvar[[1]] <- as.matrix(Q)
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
### Sanity check
plot(Y[1,], type = "l")
### Sanity check
plot(Y[1,])
mini_sum <- TBasis$X %*% pars$beta %*% X[1,]
mini_sum <- TBasis$X %*% pars$Beta %*% X[1,]
mini_sum <- TBasis$X %*% pars$Beta %*% X[1,]
for(k in 1:3){
mini_sum <- mini_sum + TBasis$X %*% pars$Lambda[,,k] %*% X[1,]
}
plot(minisum, type = "l")
plot(mini_sum, type = "l")
### Sanity check
plot(Y[1,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[1,]
for(k in 1:3){
mini_sum <- mini_sum + TBasis$X %*% pars$Lambda[,,k] %*% X[1,]
}
lines(mini_sum, type = "l")
### Sanity check
plot(Y[2,])
### Sanity check
plot(Y[2,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[2,]
for(k in 1:3){
mini_sum <- mini_sum + TBasis$X %*% pars$Lambda[,,k] %*% X[2,]
}
lines(mini_sum, type = "l")
1/.01^2
devtools::document()
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
### Sanity check
plot(Y[2,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[2,]
for(k in 1:3){
mini_sum <- mini_sum + TBasis$X %*% pars$Lambda[,,k] %*% X[2,]
}
lines(mini_sum, type = "l")
pars$Beta
pars$Lambda
pars$Eta
devtools::document()
pars <- my_main(Y, X, X, TBasis$X, 3, matlistmean,
matlistvar, c(1), c(1))
### Sanity check
plot(Y[2,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[2,]
for(k in 1:3){
mini_sum <- mini_sum + TBasis$X %*% pars$Lambda[,,k] %*% X[2,]
}
lines(mini_sum, type = "l")
### Sanity check
plot(Y[2,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[2,]
for(k in 1:3){
mini_sum <- mini_sum + pars$exp_eta[2,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[2,]
}
lines(mini_sum, type = "l")
### Sanity check
subj <- 1
plot(Y[1,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$exp_eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
mini_sum
exp_eta
pars$exp_eta
### Sanity check
subj <- 1
plot(Y[1,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$Eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
### Sanity check
subj <- 2
plot(Y[1,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$Eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
### Sanity check
subj <- 2
plot(Y[subj,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$Eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
devtools::document()
### Sanity check
subj <- 3
plot(Y[subj,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$Eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
### Sanity check
subj <- 4
plot(Y[subj,])
mini_sum <- TBasis$X %*% pars$Beta %*% X[subj,]
for(k in 1:3){
mini_sum <- mini_sum + pars$Eta[subj,k] * TBasis$X %*% pars$Lambda[,,k] %*% X[subj,]
}
lines(mini_sum, type = "l")
