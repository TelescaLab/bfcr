newY[1:n,] <- Y
C <- cbind(Theta, Lambda)
#return((n * T - n_inflation)/ sum(diag(tcrossprod(newY-newX%*%t(C)%*%t(B)))))
#print(dim(tcrossprod(newY-newX%*%t(C)%*%t(B))))
return((n * T)/ sum(diag(tcrossprod(newY-newX%*%t(C)%*%t(B)))))
}
updatePrec2 <- function(Theta, Lambda, EtaM, EtaV, X, Y, B, K, v, beta){
# v is proportion of inflation
# v = 0 means no inflation
# v = 1 means complete inflation, infinite standard error aka zero precision
n <- dim(X)[1]
d <- dim(X)[2]
T <- dim(B)[1]
n_inflation <- v * n * T
newX <- matrix(0, nrow = (K+1)*n, ncol = (K+1)*d)
cppgetX(EtaP$M, EtaP$V, X, newX)
#newX <- GetX(EtaM, EtaV, X, beta)
newY <- matrix(0, nrow = (K+1)*n, ncol = T)
newY[1:n,] <- Y
C <- cbind(Theta, Lambda)
return((n * T - n_inflation)/ sum(diag(tcrossprod(newY-newX%*%t(C)%*%t(B)))))
#print(dim(tcrossprod(newY-newX%*%t(C)%*%t(B))))
#return((n * T)/ sum(diag(tcrossprod(newY-newX%*%t(C)%*%t(B)))))
}
loglik <- function(Theta, Lambda, Prec, X, B, Y, K){
loglik <- 0
for(i in 1:n){
cov <- matrix(0, nrow = dim(B)[1], ncol = dim(B)[1])
for(k in 1:K){
LambdaCurrent <- Lambda[,(d*(k-1)+1):(d*k)]
cov <- cov + tcrossprod(B%*%LambdaCurrent%*%X[i,])
}
cov <- cov + 1/Prec * diag(dim(B)[1])
loglik <- loglik + dmvnorm(Y[i,], mean = B%*%Theta%*%X[i,], sigma = cov, log = TRUE)
}
return(loglik)
}
loglik2 <- function(Theta, Lambda, Prec, X, B, Y, K, EtaM, EtaV, beta){
n <- dim(X)[1]
d <- dim(X)[2]
tmax <- dim(B)[1]
newX <- GetX(EtaM, EtaV, X, beta)
newY <- matrix(0, nrow = (K+1)*n, ncol = tmax)
C <- cbind(Theta, Lambda)
return(n*tmax/2*log(Prec) - 1/2 * Prec * sum(diag(tcrossprod(newY-newX%*%t(C)%*%t(B)))))
}
GetX <- function(EtaM, EtaV, X, beta){
K <- dim(EtaV)[1]
D <- dim(X)[2]
n <- dim(X)[1]
newX <- matrix(0, nrow = n * (1+K), ncol = (K + 1) * D)
for(i in 1:n){
newX[i,1:D] <- X[i,]
for(k in 1:K){
newX[i, (k*D+1):((k+1)*D)] <- EtaM[k,i] * X[i,]
}
}
# Basically try to find matrix A st t(A)%*%A = kronecker(EtaV[,,1],outer(X[1,],X[1,]))
myseq <- seq(from = n, to = n*(1+K), by = K)
for(i in 1:n){
eig <- eigen(1/beta * EtaV[,,i], symmetric = TRUE)
if(K == 1){
E <- sqrt(as.numeric(X[i,]%*%X[i,]) * eig$values[1])
V <- outer(eig$vectors[,1], X[i,])
tempx <- E*t(V)
} else{
E <- diag(c(sqrt(as.numeric(X[i,]%*%X[i,])) * sqrt(pmax(eig$values[1:K], rep(0,K)))))
V <- kronecker(eig$vectors,eigen(outer(X[i,],X[i,]))$vectors[,1])
tempx <- E%*%t(V)
}
newX[(myseq[i]+1):(myseq[i+1]), (D+1):((K+1)*D)] <- tempx
}
return(newX)
}
GetX2 <- function(EtaM, EtaV, X, beta){
K <- dim(EtaV)[1]
D <- dim(X)[2]
n <- dim(X)[1]
newX <- matrix(0, nrow = n * (1+K), ncol = (K + 1) * D)
for(i in 1:n){
newX[i,1:D] <- X[i,]
for(k in 1:K){
newX[i, (k*D+1):((k+1)*D)] <- EtaM[k,i] * X[i,]
}
}
# Basically try to find matrix A st t(A)%*%A = kronecker(EtaV[,,1],outer(X[1,],X[1,]))
myseq <- seq(from = n, to = n*(1+K), by = K)
# for(i in 1:n){
#   eig <- eigen(1/beta * EtaV[,,i], symmetric = TRUE)
#   if(K == 1){
#     E <- sqrt(as.numeric(X[i,]%*%X[i,]) * eig$values[1])
#     V <- outer(eig$vectors[,1], X[i,])
#     tempx <- E*t(V)
#   } else{
#     E <- diag(c(sqrt(as.numeric(X[i,]%*%X[i,])) * sqrt(pmax(eig$values[1:K], rep(0,K)))))
#     V <- kronecker(eig$vectors,eigen(outer(X[i,],X[i,]))$vectors[,1])
#     tempx <- E%*%t(V)
#
#   }
#   newX[(myseq[i]+1):(myseq[i+1]), (D+1):((K+1)*D)] <- tempx
# }
for(i in 1:n){
mychol <- kronecker(chol(EtaP$V[,,i]), t(X[i,]))
newX[(myseq[i]+1):(myseq[i+1]), (D+1):((K+1)*D)] <- mychol
}
return(newX)
}
identifyLambda <- function(Lambda, K){
D <- dim(Lambda)[2] / K
p <- dim(Lambda)[1]
L <- matrix(0, nrow = p, ncol = D * K)
for(d in 1:D){
L[,(1:K) + rep((d-1)*K, K)] <- Lambda[,seq(from = d, to = d + (K-1)*D, by = D)]
}
Lk <- L[1:K,1:K]
mychol <- t(chol(Lk%*%t(Lk)))
P <- solve(mychol, Lk)
for(d in 1:D){
L[,(1:K) + rep((d-1)*K, K)] <- L[,(1:K) + rep((d-1)*K, K)] %*% t(P)
}
#for(k in 1:(K-1)){
# L[1:k,k+1] <- rep(0, k)
#}
for(k in 1:K){
Lambda[,1:D + rep((k-1)*D, D)] <- L[,seq(from = k, to = D*K, by = K)]
}
return(list(Lambda = Lambda, P = t(P)))
}
rotateEta <- function(EtaM, EtaV, P){
n <- dim(EtaM)[2]
for(i in 1:n){
EtaM[,i] <- P%*%EtaM[,i]
EtaV[,,i] <- P%*%EtaV[,,i]%*%t(P)
}
return(list(M = EtaM, V = EtaV))
}
beta <- 1
}
nsim <- 100
logTruen50 <- numeric(nsim)
logSimn50 <- numeric(nsim)
CovSimn50 <- numeric(nsim)
MeanSimn50 <- numeric(nsim)
eigenvec1n50 <- numeric(nsim)
eigenvec2n50 <- numeric(nsim)
eigenval1n50 <- numeric(nsim)
eigenval2n50 <- numeric(nsim)
j <- 1
{
print(j)
set.seed(j)
n <- 300
tmax <- 100
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
sourceCpp("EMfuncs.cpp")
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
sourceCpp("EMfuncs.cpp")
param <- cpp_EM(X, B, Y, K,12)
install.packages("microbenchmark")
library(microbenchmark)
microbenchmark(param <- cpp_EM(X, B, Y, K,12), times = 5)
microbenchmark(param <- cpp_EM(X, B, Y, K,12), times = 5)
microbenchmark(param <- cpp_EM(X, B, Y, K,1), times = 5)
sourceCpp("EMfuncs.cpp")
microbenchmark(param <- cpp_EM(X, B, Y, K,1), times = 5)
microbenchmark(param <- cpp_EM(X, B, Y, K,12), times = 5)
microbenchmark(param <- cpp_EM(X, B, Y, K,12), times = 5)
{
print(j)
set.seed(j)
n <- 50
tmax <- 100
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
sourceCpp("EMfuncs.cpp")
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
x <- c(1,.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
{
print(j)
set.seed(j)
n <- 250
tmax <- 100
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
sourceCpp("EMfuncs.cpp")
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
j <-2
{
print(j)
set.seed(j)
n <- 250
tmax <- 100
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
newx <- matrix(0, nrow = 500, ncol = 10)
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
{
print(j)
set.seed(j)
n <- 500
tmax <- 500
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)
sum((Btru%*%Theta%*%x)^2)*100
x <- c(1,-1)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
matplot(t(Y),type="l")
{
print(j)
set.seed(j)
n <- 110
tmax <- 400
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
#newx <- matrix(0, nrow = 500, ncol = 10)
#microbenchmark(cppgetX(param$EtaM, param$EtaV, X, newx, 23))
dev.off()
#newx <- matrix(0, nrow = 500, ncol = 10)
#microbenchmark(cppgetX(param$EtaM, param$EtaV, X, newx, 23))
dev.off()
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
x <- c(1,.5)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,-.5)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,-.2)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
