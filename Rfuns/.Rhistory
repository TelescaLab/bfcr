covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
sourceCpp("EMfuncs.cpp")
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
j <-2
{
print(j)
set.seed(j)
n <- 250
tmax <- 100
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
newx <- matrix(0, nrow = 500, ncol = 10)
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
par(mfrow = c(1,2))
persp3D(1:tmax,1:tmax, covtruth, theta=90,phi=10)
persp3D(1:tmax,1:tmax, covest, theta=90,phi=10, zlim = c(min(unlist(covtruth)),max(unlist(covtruth))))
{
print(j)
set.seed(j)
n <- 500
tmax <- 500
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,-.5)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)
sum((Btru%*%Theta%*%x)^2)*100
x <- c(1,-1)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
plot(B%*%param$Theta%*%x,type="l")
lines(Btru%*%Theta%*%x, col = "blue")
matplot(t(Y),type="l")
{
print(j)
set.seed(j)
n <- 110
tmax <- 400
p <- 12
T <- seq(from = 0, to = 1, length.out = tmax)
library(plot3D)
library(splines)
Btru <- bs(T, df = p, intercept = TRUE)
#X <- cbind(rep(1,n))
X <- cbind(rep(1,n),runif(n,min=-1,max=1))
d <- dim(X)[2]
Eta1 <- rnorm(n)
Eta2 <- rnorm(n)
Y <- matrix(0, nrow = n, ncol = tmax)
#Lambda1 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
#Lambda2 <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = d)
Lambda1 <- L1
Lambda2 <- L2
#Lambda%*%t(Lambda)
#Theta <- matrix(rnorm(p * dim(X)[2]), nrow = p, ncol = dim(X)[2])
E <- matrix(rnorm(tmax * n,sd=.01), nrow = n, ncol = tmax)
Y <- X%*%t(Theta)%*%t(Btru) + diag(Eta1)%*%X%*%t(Lambda1)%*%t(Btru) + E + diag(Eta2)%*%X%*%t(Lambda2)%*%t(Btru)# + E
inflation <- 5
Et1 <- matrix(rnorm(tmax * n, sd = inflation), nrow = n, ncol = tmax)
Yt <- Y + Et1
}
{
set.seed(1)
p <- 15
B <- bs(T, df = p, intercept = TRUE)
K <- 4
param <- cpp_EM(X, B, Y, K,12)
cpploglik(Theta, cbind(L1,L2), 1/.01^2, X, Btru, Y, 2,1)
}
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
covtruth <- Btru%*%Lambda1%*%outer(x,x)%*%t(Lambda1)%*%t(Btru) + Btru%*%Lambda2%*%outer(x,x)%*%t(Lambda2)%*%t(Btru)
sum((covest - covtruth)^2)/sum((covtruth)^2)*100
#newx <- matrix(0, nrow = 500, ncol = 10)
#microbenchmark(cppgetX(param$EtaM, param$EtaV, X, newx, 23))
dev.off()
#newx <- matrix(0, nrow = 500, ncol = 10)
#microbenchmark(cppgetX(param$EtaM, param$EtaV, X, newx, 23))
dev.off()
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,0)
sum((B%*%param$Theta%*%x - Btru%*%Theta%*%x)^2)/sum((Btru%*%Theta%*%x)^2)*100
covest <- matrix(0, p, p)
for(k in 1:K){
covest <- covest + param$Lambda[,(d*(k-1)+1):(d*k)]%*%outer(x,x)%*%t(param$Lambda[,(d*(k-1)+1):(d*k)])
}
covest <- B%*%covest%*%t(B)
x <- c(1,.5)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,-.5)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
x <- c(1,-.2)
plot(Btru%*%Theta%*%x, type = "l")
lines(B%*%param$Theta%*%x, col = "blue")
library(MASS)
library(plot3D)
library(dlnm)
library(BayesianConditionalFPCA)
library(rstan)
library(loo)
library(tidyverse)
setwd("E:/Rcpp stuff/BayesianConditionalFPCA/Rfuns")
source('simulated_data.r')
#matplot(t, t(Y), type = "l", col = "black", xlab = "Time", ylab = "Response")
par(mfrow = c(1,2))
matplot(t, t(Y[1:(n/2),]), type = "l", xlab = "Time", ylab = "Response", col = "black", main = "Group 1")
matplot(t, t(Y[(n/2 + 1):n,]), type = "l", xlab = "Time", ylab = "Response", col = "black", main = "Group 2")
par(mfrow = c(1,1))
### MCMC ###
K <- 2
Basis <- ps(t, df = 16, intercept = TRUE)
X_red <- cbind(X, X[,2]^2, X[,2]^3)
mcmc_results <- run_mcmc_Morris(Y, t, X_red, X_red, Basis, K, iter = 5000, burnin = 5000, nchains = 1, thin = 3, loglik = 1)
### Visualization ###
sub <- 10
X_red
X
mcmc_results <- run_mcmc_Morris(Y, t, X, X, Basis, K, iter = 5000, burnin = 5000, nchains = 1, thin = 3, loglik = 1)
### Visualization ###
sub <- 10
posterior_intervals <- get_posterior_predictive_bands2(mcmc_results, c(.025, .5, .975))
colnames(posterior_intervals) <- c("ID", "Time", "Y", "Lower_P", "Median_P", "Upper_P", "Lower_M", "Median_M", "Upper_M")
posterior_intervals <- as_tibble(posterior_intervals)
posterior_intervals %>%
filter(ID == sub) %>%
ggplot(aes(x = Time, y = Y)) +
geom_point(na.rm = TRUE) +
geom_ribbon(aes(ymin = Lower_P, ymax = Upper_P), alpha = 0.3) +
theme_bw()
### Posterior mean bands ###
sub <- 1
xi <- X[sub,]
alpha <- .05
coef_bands <- get_posterior_means(mcmc_results, xi, alpha)
coef_bands <- cbind(t, coef_bands)
colnames(coef_bands) <- c("Time", "Lower", "Mean", "Upper")
coef_bands <- as_tibble(coef_bands)
coef_bands %>%
ggplot(aes(x = Time)) +
geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.3, fill = "blue") +
geom_line(aes(y = Mean)) +
xlab("Time") +
ylab("Response") +
ggtitle("Conditional mean bands") +
theme_bw()
plot(t, coef_bands$Upper, type = "l", ylim = c(-.2, 1.2), xlab = "Time", ylab = "Response")
lines(t, coef_bands$Lower)
lines(t, Btru%*%Theta1 %*% X[sub,],col="green")
plot(t, coef_bands$Upper, type = "l", ylim = c(-.2, 1.2), xlab = "Time", ylab = "Response")
lines(t, coef_bands$Lower)
lines(t, Btru%*%Theta1 %*% X[sub,],col="green")
### Posterior mean bands ###
sub <- 13
xi <- X[sub,]
alpha <- .05
coef_bands <- get_posterior_means(mcmc_results, xi, alpha)
coef_bands <- cbind(t, coef_bands)
colnames(coef_bands) <- c("Time", "Lower", "Mean", "Upper")
coef_bands <- as_tibble(coef_bands)
coef_bands %>%
ggplot(aes(x = Time)) +
geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.3, fill = "blue") +
geom_line(aes(y = Mean)) +
xlab("Time") +
ylab("Response") +
ggtitle("Conditional mean bands") +
theme_bw()
plot(t, coef_bands$Upper, type = "l", ylim = c(-.2, 1.2), xlab = "Time", ylab = "Response")
lines(t, coef_bands$Lower)
lines(t, Btru%*%Theta1 %*% X[sub,],col="green")
mcmc_results <- run_mcmc_Morris(Y, t, X, X, Basis, K, iter = 5000, burnin = 5000, nchains = 1, thin = 3, loglik = 1)
### Posterior mean bands ###
sub <- 13
xi <- X[sub,]
alpha <- .05
coef_bands <- get_posterior_means(mcmc_results, xi, alpha)
coef_bands <- cbind(t, coef_bands)
colnames(coef_bands) <- c("Time", "Lower", "Mean", "Upper")
coef_bands <- as_tibble(coef_bands)
coef_bands %>%
ggplot(aes(x = Time)) +
geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.3, fill = "blue") +
geom_line(aes(y = Mean)) +
xlab("Time") +
ylab("Response") +
ggtitle("Conditional mean bands") +
theme_bw()
plot(t, coef_bands$Upper, type = "l", ylim = c(-.2, 1.2), xlab = "Time", ylab = "Response")
lines(t, coef_bands$Lower)
lines(t, Btru%*%Theta1 %*% X[sub,],col="green")
coef_bands <- get_posterior_coefs(mcmc_results, .05)
coef_bands <- tibble(Frequency = rep(t, times = dim(X_red)[2]),
Covariate = rep(c("Intercept", "Age", "Age squared", "Age cubed"), each = dim(Basis)[1]),
Lower = c(coef_bands$lower),
Mean = c(coef_bands$mean),
Upper = c(coef_bands$upper))
coef_bands <- get_posterior_coefs(mcmc_results, .05)
coef_bands <- tibble(Frequency = rep(t, times = dim(X)[2]),
Covariate = rep(c("Intercept", "Age"), each = dim(Basis)[1]),
Lower = c(coef_bands$lower),
Mean = c(coef_bands$mean),
Upper = c(coef_bands$upper))
coef_bands %>%
ggplot(aes(x = Frequency)) +
geom_ribbon(aes(ymin = Lower, ymax = Upper, fill = Covariate), alpha = 0.5) +
geom_line(aes(y = Mean)) +
geom_hline(yintercept = 0) +
facet_wrap(Covariate ~., scales = "free") +
ylab("Power") +
theme_minimal()
### Some covariance visualization ###
sub <- 100
evals <- 2
zi <- X[sub, ]
alpha <- .05
dim(X)
### Some covariance visualization ###
sub <- 4
evals <- 2
zi <- X[sub, ]
alpha <- .05
eigen_bands <- get_posterior_eigen2(mcmc_results, evals, zi, alpha)
eig_names <- c()
eig_labs <- c()
for(k in 1:evals){
eig_names <- c(eig_names, paste("Eigenfunction", k))
eig_labs <- c(eig_labs, paste("Eigenfunction", k, " ", round(eigen_bands$eigenval_pve_intervals[1,k], 2), "-", round(eigen_bands$eigenval_pve_intervals[3,k], 2)))
}
names(eig_labs) <- eig_names
eigen_bands_tibble <- tibble(Time = rep(t, evals),
number = factor(rep(eig_names, each = length(t))),
lower = c(eigen_bands$lower),
mean = c(eigen_bands$mean),
upper = c(eigen_bands$upper),
val_lower = rep(eigen_bands$eigenval_intervals[1,], each = length(t)),
val_median = rep(eigen_bands$eigenval_intervals[2,], each = length(t)),
val_upper = rep(eigen_bands$eigenval_intervals[3,], each = length(t)))
eigen_bands_tibble %>%
ggplot(aes(x = Time)) +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = number), alpha = 0.5) +
geom_line(aes(y = mean)) +
facet_wrap(number ~., labeller = labeller(number = eig_labs)) +
theme_bw() +
theme(legend.position="none")
eigen_bands$magnitude
# aX <- list(title = "Time")
# aY <- list(title = "Time")
# aZ <- list(title = "Response")
# plotly::plot_ly(x = t, y = t, z = eigen_bands$surface, type = "surface") %>%
#   plotly::layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode = "turntable"))
# plot(eigen_bands$raw_magnitude, type = "l")
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(X[sub,], X[sub,]) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(X[sub,], X[sub,]) %*% t(Lambda2) %*% t(Btru)
par(mfrow = c(1,2))
persp3D(t, t, eigen_bands$surface)
persp3D(t, t, truecov)
### MCMC ###
K <- 4
Basis <- ps(t, df = 16, intercept = TRUE)
X_red <- cbind(X, X[,2]^2, X[,2]^3)
mcmc_results <- run_mcmc_Morris(Y, t, X, X, Basis, K, iter = 5000, burnin = 5000, nchains = 1, thin = 3, loglik = 1)
### Some covariance visualization ###
sub <- 4
evals <- 2
zi <- X[sub, ]
alpha <- .05
eigen_bands <- get_posterior_eigen2(mcmc_results, evals, zi, alpha)
eig_names <- c()
eig_labs <- c()
for(k in 1:evals){
eig_names <- c(eig_names, paste("Eigenfunction", k))
eig_labs <- c(eig_labs, paste("Eigenfunction", k, " ", round(eigen_bands$eigenval_pve_intervals[1,k], 2), "-", round(eigen_bands$eigenval_pve_intervals[3,k], 2)))
}
names(eig_labs) <- eig_names
### Some covariance visualization ###
sub <- 4
evals <- 4
zi <- X[sub, ]
alpha <- .05
eigen_bands <- get_posterior_eigen2(mcmc_results, evals, zi, alpha)
eig_names <- c()
eig_labs <- c()
for(k in 1:evals){
eig_names <- c(eig_names, paste("Eigenfunction", k))
eig_labs <- c(eig_labs, paste("Eigenfunction", k, " ", round(eigen_bands$eigenval_pve_intervals[1,k], 2), "-", round(eigen_bands$eigenval_pve_intervals[3,k], 2)))
}
names(eig_labs) <- eig_names
eigen_bands_tibble <- tibble(Time = rep(t, evals),
number = factor(rep(eig_names, each = length(t))),
lower = c(eigen_bands$lower),
mean = c(eigen_bands$mean),
upper = c(eigen_bands$upper),
val_lower = rep(eigen_bands$eigenval_intervals[1,], each = length(t)),
val_median = rep(eigen_bands$eigenval_intervals[2,], each = length(t)),
val_upper = rep(eigen_bands$eigenval_intervals[3,], each = length(t)))
eigen_bands_tibble %>%
ggplot(aes(x = Time)) +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = number), alpha = 0.5) +
geom_line(aes(y = mean)) +
facet_wrap(number ~., labeller = labeller(number = eig_labs)) +
theme_bw() +
theme(legend.position="none")
eigen_bands$magnitude
# aX <- list(title = "Time")
# aY <- list(title = "Time")
# aZ <- list(title = "Response")
# plotly::plot_ly(x = t, y = t, z = eigen_bands$surface, type = "surface") %>%
#   plotly::layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode = "turntable"))
# plot(eigen_bands$raw_magnitude, type = "l")
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(X[sub,], X[sub,]) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(X[sub,], X[sub,]) %*% t(Lambda2) %*% t(Btru)
par(mfrow = c(1,2))
persp3D(t, t, eigen_bands$surface)
persp3D(t, t, truecov)
par(mfrow = c(1,1))
X
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, 0, x)
Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
counter <- counter + 1
}
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, x)
Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
counter <- counter + 1
}
Cov_mat
plot(Cov_mat[,1], type = "l", ylim = c(.03, .25))
lines(Cov_mat[,3])
plot(Cov_mat[,1], type = "l")
lines(Cov_mat[,3])
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, x)
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(z, z) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(z, z) %*% t(Lambda2) %*% t(Btru)
counter <- counter + 1
}
Btru%*%Lambda1
Btru%*%Lambda1%*%outer(c(1,1),c(1,1))
Btru%*%Lambda1%*%outer(c(1,1),c(1,1))%*%t(Lambda1)%*%t(Btru)
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, x)
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(z, z) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(z, z) %*% t(Lambda2) %*% t(Btru)
Cov_meat[counter,] <- sum(eigen(truecov))
counter <- counter + 1
}
Btru %*% Lambda1 %*% outer(z, z)
z
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, x)
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(zi, zi) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(zi, zi) %*% t(Lambda2) %*% t(Btru)
Cov_meat[counter,] <- sum(eigen(truecov))
counter <- counter + 1
}
X_seq <- seq(from = -2, to = 2, by = .1)
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
counter <- 1
for(x in X_seq){
zi <- c(1, x)
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(zi, zi) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(zi, zi) %*% t(Lambda2) %*% t(Btru)
Cov_mat[counter] <- sum(eigen(truecov))
counter <- counter + 1
}
X_seq <- seq(from = -2, to = 2, by = .1)
counter <- 1
Cov_mat <- matrix(0, nrow = length(X_seq), ncol = 3)
for(x in X_seq){
zi <- c(1, x)
#  Cov_mat[counter,] <- get_posterior_eigen2(mcmc_results, 4, zi, .05)$magnitude
truecov <- matrix(0, nrow = tmax, ncol = tmax)
truecov <- Btru %*% Lambda1 %*% outer(zi, zi) %*% t(Lambda1) %*% t(Btru) +
Btru %*% Lambda2 %*% outer(zi, zi) %*% t(Lambda2) %*% t(Btru)
Cov_mat[counter] <- sum(eigen(truecov)$values)
counter <- counter + 1
}
plot(Cov_mat,type="l")
Cov_mat
plot(Cov_mat[,1], type = "l")
coef_bands <- get_posterior_means(mcmc_results, xi, alpha)
coef_bands
dim(Y)
xi
alpha
